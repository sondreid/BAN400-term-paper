<<<<<<< HEAD
transform(.,
week = as.numeric(week),
deaths = as.integer(deaths))
return(data)
}
"Reading excel file with given range of rows and columns, and selected sheet"
data_sweden <-
read_excel("../datasett/Sweden/sweden_scb.xlsx",
sheet = "Tabell 7",
range = "Tabell 7!a9:s62")
#### Data Sweden ---------------------------------------------------------------
"Reading excel file with given range of rows and columns, and selected sheet"
data_sweden <-
read_excel("../datasett/Sweden/sweden_scb.xlsx",
sheet = "Tabell 7",
range = "Tabell 7!a9:s62")
"Creates a new data frame containing data from 2015-2019.
Comment: Check genderFunc_vector description in function section, and
sapply() description in description for data_norway (**)"
data_sweden_2015_2019 <-
data_sweden %>%
select(1:10, -"2015-2019") %>%    # Deselecting with '-' operator
pivot_longer(
cols = !"Vecka",
names_to = "values",
values_to = "deaths") %>%
mutate(year = "2015-2019",
gender = sapply(strsplit(values ," "), `[`, 1),
agegroup = sapply(strsplit(values ," "), `[`, 2)) %>%
select(-"values") %>%
rename(week = "Vecka")
"Creates a new data frame containing data from 2020"
data_sweden_2020 <- data_sweden %>%
select("Vecka", 12:19 ) %>%
pivot_longer(
cols = !"Vecka",
names_to = "values",
values_to = "deaths") %>%
mutate(year = "2020",
gender = sapply(strsplit(values ," "), `[`, 1),
agegroup = sapply(strsplit(values ," "), `[`, 2)) %>%
select(-"values") %>%
rename(week = "Vecka") %>%
filter(deaths != 0.0) # In order to remove zero-deaths-week
"Combines data frames to a single data frame, mutates agegroup column to contain
the standardized agegrouping, selects useful columns and coerce these to
prefered datatypes"
data_sweden <- rbind(data_sweden_2015_2019,
data_sweden_2020) %>%
mutate(country = "Sweden") %>%
select(gender,
agegroup,
year,
week,
deaths,
country)
rm(data_sweden_2015_2019)
rm(data_sweden_2020)
"Reading excel file with given range of rows and columns"
data_norway <- read_excel("../datasett/Norway/norway_ssb.xlsx",
range = "Dode1!a4:AA1594")
# Binding all data frames created except from 2020
data_uk <- do.call("rbind", list(data_uk_2014,
data_uk_2015,
data_uk_2016,
data_uk_2017,
data_uk_2018,
data_uk_2019,
data_uk_2020)) %>%
select(gender,
agegroup,
year,
week ,
deaths,
country) %>%
group_by(gender,
agegroup,
year,
week) %>%
summarise(deaths = sum(deaths)) %>%
ungroup() %>%
mutate(country = "UK")
"Gather csv filename from the France-folder in to a list"
datafiles_france <- list.files(path = "../datasett/France/",
pattern = "*.csv",
full.names = TRUE)
"Sapply() to read each file with read_csv2 with sep = ';',
then bind rows by id. The rest of the code does the cleaning"
data_france <- sapply(datafiles_france, read_csv2, simplify=FALSE) %>%
bind_rows(.id = "id") %>%
rename(day_dead = "JDEC",
month_dead = "MDEC",
year = "ADEC",
day_born = "JNAIS",
month_born = "MNAIS",
year_born = "ANAIS",
gender = "SEXE") %>%
transform(day_born = as.numeric(day_born),
month_born = as.numeric(month_born))  %>% # Replace missing values with NA
mutate(day_born = replace_na(day_born, 1), # Replace NA with 1
month_born = replace_na(month_born, 1),
date_born = ymd(paste(year_born, month_born, day_born)), ### Convert year month to single date of birth
date_dead = ymd(paste(year, month_dead, day_dead)),      ### Convert year month to single date of death
week = week(ymd(paste(year, month_dead, day_dead))),     ## Week of death
agegroup = as.period(interval(date_born, date_dead), unit = "year")$year) %>% ## Age at death
#agegroup = ageGroup_vector(age)) %>%
filter(!is.na(agegroup)) %>%
group_by(gender,
agegroup,
year,
week) %>%
summarise(deaths = n()) %>%
ungroup() %>%
mutate(country = "France")
View(data_france)
###################### Data retrieval/cleaning script ##########################
"Support for utf-8 encoding"
options(encoding="utf-8")
"Libraries for retrieval and cleaning"
library(readxl)
library(readr)
library(tidyverse)
library(types)
library(lubridate)
library(janitor)
#### Download last updated version of data -------------------------------------
download.file(url = "https://www.scb.se/en/finding-statistics/statistics-by-subject-area/population/population-composition/population-statistics/pong/tables-and-graphs/preliminary-statistics-on-deaths/",
destfile = "../datasett/Sweden/sweden_scb.xlsx")
download.file(url = "https://www.ssb.no/statbank/sq/10044673",
destfile = "../datasett/Norway/norway_ssb.xlsx")
download.file(url = "https://www.ons.gov.uk/file?uri=%2fpeoplepopulationandcommunity%2fbirthsdeathsandmarriages%2fdeaths%2fdatasets%2fweeklyprovisionalfiguresondeathsregisteredinenglandandwales%2f2020/publishedweek48202007122020155900.xlsx",
destfile = "../datasett/UK/UK_2020.xlsx")
###################### Data retrieval/cleaning script ##########################
"Support for utf-8 encoding"
options(encoding="utf-8")
"Libraries for retrieval and cleaning"
library(readxl)
library(readr)
library(tidyverse)
library(types)
library(lubridate)
library(janitor)
#### Download last updated version of data -------------------------------------
download.file(url = "https://www.scb.se/en/finding-statistics/statistics-by-subject-area/population/population-composition/population-statistics/pong/tables-and-graphs/preliminary-statistics-on-deaths/",
destfile = "../datasett/Sweden/sweden_scb.xlsx")
download.file(url = "https://www.ssb.no/statbank/sq/10044673",
destfile = "../datasett/Norway/norway_ssb.xlsx")
download.file(url = "https://www.ons.gov.uk/file?uri=%2fpeoplepopulationandcommunity%2fbirthsdeathsandmarriages%2fdeaths%2fdatasets%2fweeklyprovisionalfiguresondeathsregisteredinenglandandwales%2f2020/publishedweek48202007122020155900.xlsx",
destfile = "../datasett/UK/UK_2020.xlsx")
###################### Data retrieval/cleaning script ##########################
"Support for utf-8 encoding"
options(encoding="utf-8")
"Libraries for retrieval and cleaning"
library(readxl)
library(readr)
library(tidyverse)
library(types)
library(lubridate)
library(janitor)
#### Download last updated version of data -------------------------------------
download.file(url = "https://www.scb.se/en/finding-statistics/statistics-by-subject-area/population/population-composition/population-statistics/pong/tables-and-graphs/preliminary-statistics-on-deaths/",
destfile = "../datasett/Sweden/sweden_scb.xlsx")
download.file(url = "https://www.ssb.no/statbank/sq/10044673",
destfile = "../datasett/Norway/norway_ssb.xlsx")
download.file(url = "https://www.ons.gov.uk/file?uri=%2fpeoplepopulationandcommunity%2fbirthsdeathsandmarriages%2fdeaths%2fdatasets%2fweeklyprovisionalfiguresondeathsregisteredinenglandandwales%2f2020/publishedweek48202007122020155900.xlsx",
destfile = "../datasett/UK/UK_2020.xlsx")
#download.file(url = "", destfile = "../datasett/France/france_2020.csv")
#download.file(url = "", destfile = "../datasett/Denmark/danmark_statbank_2013-2020.xlsx")
#### Functions -----------------------------------------------------------------
"Records group-element for a given column and fills empty elements with the
stored element for each new group. The function has following parameters:
df (data frame), column index with datatype numeric and groupnameInterval, data-
type numeric, such that function know the frequency in which the groupname
occurs. The if statement evaluates the occurance of the groupname by using
modulo-operator such that the remainder is equal zero and is not an empty
value NA, then set the new groupname equals name variable. Else, fill the rest
of the given column with stored groupname. Returns the data frame (df)."
changeNonRecurringRow <- function(df,
column =? numeric,
groupnameInterval =? numeric) {
name <- ""
for (i in 1:nrow(df)) {
if ((((i-1) %% groupnameInterval) == 0) && !is.na(df[i, column]) ){
name <- df[i, column]
} else {
df[i, column] <- name
}
}
return (df)
}
"Function spesific to the UK dataset (2014-2019) that cleans the data.
The function itself transposes the dataset into two separated data frames
of male and female, and rowbinds them at the end.
* pivot_longer() is a function that decreases selected columns and increases
number of rows."
clean_data <- function(df,
year =? chr,
selectColMale,
selectColFemale){
data_male <- as.data.frame(t(df))       # t() transposes the data frame
data_female <- as.data.frame(t(df))
data_male %<>%
row_to_names(row_number = 1) %>%      # First row to column name (janitor)
select(selectColMale) %>%
mutate("Males 5" = replace_na("M")) %>%
rename(gender = "Males 5",
week = "Week number",
"1-" = "Under 1 year") %>%     # Simplifying it for getAge-function
pivot_longer(cols = !c(week, gender), # *
names_to = "agegroup",
values_to = "deaths")
data_female %<>%
row_to_names(row_number = 1) %>%
select(selectColFemale) %>%
mutate("Females 5" = replace_na("W")) %>%
rename(gender = "Females 5",
week = "Week number",
"1-" = "Under 1 year") %>%
pivot_longer(cols = !c(week, gender),   # *
names_to = "agegroup",
values_to = "deaths")
data <- rbind(data_male, data_female) %>% # rowbinds given data frames
mutate(year = rep(year),
country = "United Kingdom") %>%
transform(.,
week = as.numeric(week),
deaths = as.integer(deaths))
return(data)
}
"Function spesific to UK dataset 2020 that cleans the data. Is almost an
exact copy of the functon above, except from some specific arguments caused
of different formatting in the year 2020 for the given dataset. Alternativly,
the function above could be modified in order to fit these formatting issues,
but that would increase the number of paramters. Else, there is no new functions
introduced in this section."
custom_clean_data_2020 <- function(df,
year =? chr,
selectColMale,
selectColFemale){
data_male <- as.data.frame(t(df))
data_female <- as.data.frame(t(df))
data_male %<>%
row_to_names(row_number = 1) %>%
select(selectColMale) %>%
mutate("Males 6" = replace_na("M")) %>%
rename(gender = "Males 6",
week = "Week number",
"1-" = "<1") %>%
pivot_longer(cols = !c(week, gender),
names_to = "agegroup",
values_to = "deaths")
data_female %<>%
row_to_names(row_number = 1) %>%
select(selectColFemale) %>%
mutate("Females 6" = replace_na("W")) %>%
rename(gender = "Females 6",
week = "Week number",
"1-" = "<1") %>%
pivot_longer(cols = !c(week, gender),
names_to = "agegroup",
values_to = "deaths")
data <- rbind(data_male, data_female) %>%
mutate(year = rep(year),
country = "United Kingdom") %>%
transform(.,
week = as.numeric(week),
deaths = as.integer(deaths))
return(data)
}
#### Data Norway ---------------------------------------------------------------
"Reading excel file with given range of rows and columns"
data_norway <- read_excel("../datasett/Norway/norway_ssb.xlsx",
range = "Dode1!a4:AA1594")
"Changing the empty columns by replicating gender names (1) and agegroups (2)"
data_norway  <- changeNonRecurringRow(data_norway, 1, 53) %>% # For gender
changeNonRecurringRow(., 2, 53) # For agegroups
"Manipulating the norway's data frame.
** sapply() iterates through a give vector (column) and performs strsplit for
each element, the specified integer argument in strsplit() decide which element
in the list to retrieve."
data_norway  %<>%
pivot_longer(cols = starts_with("20"),   # Check description for clean_data()
names_to = "year",
values_to = "deaths") %>%
rename(gender = "...1",
agegroup =  "...2",
values = "...3") %>%
mutate(week =   sapply(strsplit(values, " "), `[`, 2)) %>%
filter(!is.na(gender),
year >= 2014,
deaths != 0) %>%
group_by(gender,
agegroup,
year,
week) %>%                  # In order to sum deaths into groups
summarise(deaths = sum(deaths)) %>%
ungroup() %>%                       # Ungrouped such that mutation is allowed
mutate(country = "Norway")
#### Data Sweden ---------------------------------------------------------------
"Reading excel file with given range of rows and columns, and selected sheet"
data_sweden <-
read_excel("../datasett/Sweden/sweden_scb.xlsx",
sheet = "Tabell 7",
range = "Tabell 7!a9:s62")
"Creates a new data frame containing data from 2015-2019.
Comment: Check genderFunc_vector description in function section, and
sapply() description in description for data_norway (**)"
data_sweden_2015_2019 <-
data_sweden %>%
select(1:10, -"2015-2019") %>%    # Deselecting with '-' operator
pivot_longer(
cols = !"Vecka",
names_to = "values",
values_to = "deaths") %>%
mutate(year = "2015-2019",
gender = sapply(strsplit(values ," "), `[`, 1),
agegroup = sapply(strsplit(values ," "), `[`, 2)) %>%
select(-"values") %>%
rename(week = "Vecka")
"Creates a new data frame containing data from 2020"
data_sweden_2020 <- data_sweden %>%
select("Vecka", 12:19 ) %>%
pivot_longer(
cols = !"Vecka",
names_to = "values",
values_to = "deaths") %>%
mutate(year = "2020",
gender = sapply(strsplit(values ," "), `[`, 1),
agegroup = sapply(strsplit(values ," "), `[`, 2)) %>%
select(-"values") %>%
rename(week = "Vecka") %>%
filter(deaths != 0.0) # In order to remove zero-deaths-week
"Combines data frames to a single data frame, mutates agegroup column to contain
the standardized agegrouping, selects useful columns and coerce these to
prefered datatypes"
data_sweden <- rbind(data_sweden_2015_2019,
data_sweden_2020) %>%
mutate(country = "Sweden") %>%
select(gender,
agegroup,
year,
week,
deaths,
country)
rm(data_sweden_2015_2019)
rm(data_sweden_2020)
#### Data Denmark --------------------------------------------------------------
"Reads csv-file with read_delim() and separete it by ';', alternative:
read_csv2."
data_denmark <- read_delim("../datasett/Denmark/danmark_statbank_2013-2020.csv",
delim = ";",
skip = 2)
"Manipulates the data frame by selecting useful columns with [],
and mutatating gender column in to standardized gender name."
data_denmark <-
data_denmark[-1,] %>%
rename(gender = " _1",
agegroup = " _2") %>%
mutate(gender = substr(gender, 1, 1)) %>%
changeNonRecurringRow(., 2, 22) # Fills non recurring rows with given genders
"Further manipulation of data_denmark data frame. Deselecting irrelevant
columns, transpose all columns that starts with '20' in order to create
two column names to values column and values to the deaths column. Mutating
values column in to two columns named, year and week, by executing strsplitt()
for each rows in the values vector with sapply(). Grouping before summing
deaths for given grouping, then coerce given columns in data frame to
prefered datatype."
data_denmark <-
data_denmark[-c(1,2,24,25),] %>%
pivot_longer(cols = starts_with("20"),
names_to = "values",
values_to = "deaths") %>%
mutate(year = sapply(strsplit(values, "U"),'[', 1),
week = sapply(strsplit(values, "U"), '[', 2),
country = "Denmark") %>%
filter(!is.na(agegroup),
year >= 2014) %>%
group_by(gender,
agegroup,
year,
week) %>%
summarise(deaths = sum(deaths)) %>%
ungroup() %>%                       # Ungroup such that mutation is allowed
mutate(country = "Denmark")
#### Data UK ----------------------------------------------------------------
"UK datasets differ in the way they categorize age groups in the periods
2014-2019 and 2020. As a result of that getAgeVector transforms the agegroup
and returns the lower bound of the agegroup as a numeric value. The ageuniformiy
function then places the age in a fitting agegroup."
data_uk_2014 <- read_xls("../datasett/UK/UK_2014.xls",
sheet = "Weekly Figures 2014",
range = "A2:BA40") %>%
clean_data(.,                    # Function call to clean_data
2014,
selectColMale = c(1, 21, 23:29),
selectColFemale =  c(1, 30, 32:38))
data_uk_2015 <- read_xls("../datasett/UK/UK_2015.xls",
sheet = "Weekly Figures 2015",
range = "A3:BB40") %>%
clean_data(.,
2015,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2016 <- read_xls("../datasett/UK/UK_2016.xls",
sheet = "Weekly figures 2016",
range = "A3:BB40") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
clean_data(.,
2016,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2017 <- read_xls("../datasett/UK/UK_2017.xls",
sheet = "Weekly figures 2017",
range = "A3:BB40") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
clean_data(.,
2017,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2018 <- read_xls("../datasett/UK/UK_2018.xls",
sheet = "Weekly figures 2018",
range = "A3:BB40") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
clean_data(.,
2018,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2019 <- read_xls("../datasett/UK/UK_2019.xls",
sheet = "Weekly figures 2019",
range = "A3:BB40") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
clean_data(.,
2019,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2020 <- read_xlsx("../datasett/UK/UK_2020.xlsx",
sheet = "Weekly figures 2020",
range = "A4:BC85") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
custom_clean_data_2020(.,
2020,
selectColMale = c(1, 38, 40:59),
selectColFemale =  c(1, 60, 62:81))
# Binding all data frames created except from 2020
data_uk <- do.call("rbind", list(data_uk_2014,
data_uk_2015,
data_uk_2016,
data_uk_2017,
data_uk_2018,
data_uk_2019,
data_uk_2020)) %>%
select(gender,
agegroup,
year,
week ,
deaths,
country) %>%
group_by(gender,
agegroup,
year,
week) %>%
summarise(deaths = sum(deaths)) %>%
ungroup() %>%
mutate(country = "UK")
rm(data_uk_2014)
rm(data_uk_2015)
rm(data_uk_2016)
rm(data_uk_2017)
rm(data_uk_2018)
rm(data_uk_2019)
rm(data_uk_2020)
##### Data France -----------------------------------------------------------
"Gather csv filename from the France-folder in to a list"
datafiles_france <- list.files(path = "../datasett/France/",
pattern = "*.csv",
full.names = TRUE)
"Sapply() to read each file with read_csv2 with sep = ';',
then bind rows by id. The rest of the code does the cleaning"
data_france <- sapply(datafiles_france, read_csv2, simplify=FALSE) %>%
bind_rows(.id = "id") %>%
rename(day_dead = "JDEC",
month_dead = "MDEC",
year = "ADEC",
day_born = "JNAIS",
month_born = "MNAIS",
year_born = "ANAIS",
gender = "SEXE") %>%
transform(day_born = as.numeric(day_born),
month_born = as.numeric(month_born))  %>% # Replace missing values with NA
mutate(day_born = replace_na(day_born, 1), # Replace NA with 1
month_born = replace_na(month_born, 1),
date_born = ymd(paste(year_born, month_born, day_born)), ### Convert year month to single date of birth
date_dead = ymd(paste(year, month_dead, day_dead)),      ### Convert year month to single date of death
week = week(ymd(paste(year, month_dead, day_dead))),     ## Week of death
agegroup = as.period(interval(date_born, date_dead), unit = "year")$year) %>% ## Age at death
#agegroup = ageGroup_vector(age)) %>%
filter(!is.na(agegroup)) %>%
group_by(gender,
agegroup,
year,
week) %>%
summarise(deaths = n()) %>%
ungroup() %>%
mutate(country = "France")
#### Remove functions that are no longer needed in memory ----------------------
rm(changeNonRecurringRow)
rm(clean_data)
rm(custom_clean_data_2020)
rm(datafiles_france)
"Reading excel file with given range of rows and columns"
data_norway <- read_excel("../datasett/Norway/norway_ssb.xlsx",
range = "Dode1!a4:AA1594")
=======
year,
week,
country,
deaths,
expected_deaths,
excess_deaths)
return (new_df)
}
"Rowbind all datasets to a combined dataset, calling addExpectedDeaths()"
assembleAllData <- function(dfVector = c("data_norway",
"data_sweden",
"data_denmark",
"data_france",
"data_uk")) {
totaldata <- addExpectedDeaths(eval(as.name(dfVector[1])))
for (i in 2:length(dfVector)) {
totaldata <- rbind(totaldata,
addExpectedDeaths(eval(as.name(dfVector[i]))))
}
totaldata %<>% filter(week <= minimalweeks)
return (totaldata)
}
"Function that takes one data frame, set of agegroups, given genders by
default, one country, selfconstructed .pdf path to store the plot and
prefered y-axis interval. Much of the same description as for the
plotfunction_diff except from the fill-part. At the end it returns an
interactive plot which is facet wraped given by agegroup."
plotfunction <- function(df,
agevector = c("0-64", "65-79", "80-84", "85+"),
gendervector = c("M", "F"),
countryparam,
filename,
ymin = NA,
ymax = NA) {
plot <- df %>%
filter(agegroup %in% agevector,
gender %in% gendervector,
country %in% countryparam) %>%
ggplot() +
geom_smooth(aes(x = week,
y = deaths,
color = agegroup),
se = FALSE) +
geom_smooth(aes(x = week,
y = expected_deaths,
color = "Expected Deaths"),
fill = "lightblue") +
scale_color_viridis(discrete = TRUE) +
ylab("Deaths") +
xlab ("Weeks") +
ggtitle(paste("Expected vs. Actual Deaths in 2020",
"[", countryparam, "]")) +
theme_ipsum(base_family = "Helvetica",
plot_title_size = 12,
base_size = 14,
axis_title_size = 12)
if (!is.na(ymin) | !is.na(ymax)){
plot <- plot + ylim(ymin, ymax)
}
plot <- plot +
facet_wrap(~agegroup, nrow = 1) # Wraps number of agegroups on a single row
ggsave(paste("../results/", filename, sep = ""))
return (ggplotly(plot))           # ggplotly for interactivity
}
"Plots all the agegroups in a country in single plots"
plotter <- function(df, gender = c("M", "F"), country){
for (agegroup in levels(df$agegroup)){
print(plotfunction_diff(df,
agevector = agegroup,
gendervector = gender,
country = country))
}
}
"Stores created plots in pdf-file"
plot_pdf <- function(filename, plot){
pdf(paste("../results/",filename, sep=""), onefile = TRUE)
plotter(plot)
dev.off()
}
#### Total Data ----------------------------------------------------------------
"Totaldata is a dataframe which contains all the created data frames to
a consolidated data frame"
totaldata <- assembleAllData()
##### Test statistics-----------------------------------------------------------
"Is the difference in deaths and expected deaths statistically significant?"
"Function that conducts a two sided welch t.test to test whether 2020
deaths are statistically different than expected deaths. Compares x_mean and
y_mean to find out whether deaths are higher or lower. Tags the p.value along
with a string indicating whether it is above or below the estimated deaths, and
returns them as a list"
t_testFunc <- function(df,
agegroupvector = c("0-64", "65-79", "80-84", "85+"),
countryparam =? character ) {
testset <- df %>%
filter(country == countryparam,
agegroup %in% agegroupvector,
week >= 12) %>%
group_by(week) %>%
summarise(deaths = sum(deaths),
expected_deaths = sum(expected_deaths)) %>%
select(deaths,
expected_deaths)
t_test <- t.test(testset$deaths,
testset$expected_deaths,
alternative = "two.sided",
var.equal = FALSE)
# Determine whether the mean estimate mean deaths are higher or
# lower than the expected deaths
x_mean <- as.integer(t_test$estimate[1])
y_mean <- as.integer(t_test$estimate[2])
if (x_mean < y_mean) {return(list("Below", t_test$p.value)) }
else return(list("Above", t_test$p.value))
}
"Function that returns a string
Calls t_testFunc on a given country, uses totaldata as df as opposed to tabledata.
Returns a string based on the result from t_test_func."
tableTests <- function(country) {
test <- t_testFunc(totaldata,
agegroupvector = c("0-64", "65-79", "80-84", "85+"),
countryparam = country)
p.value <- test[[2]]
outputlist <- list(test[[1]], p.value)
if (p.value > 0.15) outputlist[[1]] <- "Normal"
else if (test[[1]] == "Above") {
if      (p.value < 0.025) outputlist[[1]] <- "Above ***"
else if (p.value < 0.05)  outputlist[[1]] <- "Above **"
else if (p.value < 0.15)  outputlist[[1]] <- "Above *"
}
else if (test[[1]] == "Below")  {
if      (p.value < 0.025) outputlist[[1]] <- "Below ***"
else if (p.value < 0.05)  outputlist[[1]] <- "Below **"
else if (p.value < 0.15)  outputlist[[1]] <- "Below *"
}
return (outputlist)
}
" Returns the first element of a list generated by tableTests func"
getTableTestFirst <- function(country) {
return (tableTests(country)[[1]])
}
getTableTestFirst <- Vectorize(getTableTestFirst)
" Returns the second element of a list generated by tableTests func"
getTableTestPvalue <- function(country) {
return (round(tableTests(country)[[2]], 4))
}
getTableTestPvalue <- Vectorize(getTableTestPvalue)
## Tables  ---------------------------------------------------------------------
totaldataFilter <- totaldata %>% filter(week >= 12)
shortTable_data <- totaldataFilter  %>%
group_by(country) %>%
summarise(excess_deaths = sum(excess_deaths)) %>%
## Max excess deaths per week
cbind(.,
totaldataFilter %>%
group_by(country, week) %>%
summarise(excess_deaths = sum(excess_deaths)) %>%
group_by(country) %>%
filter(excess_deaths == max(excess_deaths)) %>%
rename(max_deaths_perweek = excess_deaths )) %>%
select(-3) %>%
## Percentage above normal
cbind(.,
totaldataFilter %>% filter(week >= 12) %>%
group_by(country) %>%
summarise(percentage_above_normal = percent((
sum(deaths)/sum(expected_deaths)))) %>%
select(-country)) %>%
mutate(statistically_significant = getTableTestFirst(country),
p.value = getTableTestPvalue(country)) %>%
rename("Country"                          = country,
"Total Excess Deaths"              = excess_deaths,
"Highest Excess Deaths in a Week"  = max_deaths_perweek,
"Week: Highest Excess deaths"      = week,
"Percentage of Normal Deaths"      = percentage_above_normal,
"Statistically Significant"        = statistically_significant,
"P-value"                          = p.value)
"Function that returns shortTableData using the formattable package"
shortTable <- function() {
lightred = "#ff7f7f"
outputTable <- formattable(shortTable_data, list(
"Total Excess Deaths"              = color_tile("white", lightred),
"Highest Excess Deaths in a Week"  = color_bar(lightred),
"Percentage of Normal Deaths"      = color_bar(lightred),
"Statistically Significant"        =
formatter("span", style = x ~ ifelse(substring(x, 1, 5) == "Above",
style(color = "red",
font.weight = "bold"),
NA))))
return (outputTable)
}
"Function that returns a sortable table which contains weekly deaths, expected
deaths and excess deaths according to agegroup and gender"
longTable <- function() {
outputtable <- datatable(totaldata %>%
select(-year),
colnames = c("Gender",
"Agegroup",
"Week",
"Country",
"Deaths",
"Expected Deaths",
"Excess Deaths"),
filter = "top",
options = list(pageLength = 20, autoWidth = TRUE),
class = 'cell-border stripe'
)
return (outputtable)
}
save(shortTable, shortTable_data, file = "Shiny/data/tableData.Rda")
save(totaldata, file = "Shiny/data/totaldata.Rda")
######################### Data Analysis Script #################################
"Support for utf-8 encoding"
options(encoding="utf-8")
"Libraries for the analysis"
library(kableExtra)
library(tidyverse)
library(tidygraph)
library(hrbrthemes)
library(viridis)
library(dygraphs)
library(xts)
library(lubridate)
library(plotly)
library(types)
library(pdftools)
library(gt)
library(scales)
library(formattable)
library(DT)
library(magrittr)
"Loading data frames retrieved from standardisation.r"
load("../datasett/processed_data_all_countries.Rda")
#### Functions -----------------------------------------------------------------
"This is a function that takes a given data frame, single agegrouping, gender,
which by default is Male 'M' and Female 'F' and also given countries. The
mutation of min_reg and max_reg is done in order to fill the area inbetween
the actual and expected regression lines."
plotfunction_diff <- function(df,
agegrouping =? character,
gendervector = c("M", "F"),
countryparam) {
df <- df %>%
filter(agegroup == agegrouping,
gender %in% gendervector,
country == countryparam)
regline_fitted <- loess(df$deaths ~ df$week)
regline_expected <- loess(df$expected_deaths ~ df$week)
plot <- df %>%
mutate(min_reg = pmin(regline_fitted$fitted,
regline_expected$fitted),
max_reg = pmax(regline_fitted$fitted,
regline_expected$fitted)) %>%
ggplot() +
geom_smooth(aes(x = week,
y = deaths,
color = agegroup),
se = FALSE) +             # Confidence interval
geom_smooth(aes(x = week,
y = expected_deaths,
color = "Expected Deaths")) +
geom_ribbon(aes(week,
ymin = min_reg,
ymax = max_reg),
fill = "red",
alpha = 0.5) +
scale_color_viridis(discrete = TRUE) +
ylab("Deaths") +
xlab ("Weeks") +
ggtitle(paste("Expected vs. Actual Deaths in 2020",
"[", countryparam, "]",
"[Agegroup: ", agegrouping, "]")) +
theme_ipsum(base_family = "Helvetica",
plot_title_size = 12,
base_size = 14,
axis_title_size = 12)
return (ggplotly(plot)) # ggplotly for interactivity
}
"Function that finds the number of weeks we have data accounted for in 2020"
weeksin2020 <- function(df) {
return (nrow(df %>%
filter(year == 2020) %>%
select(week) %>%
unique()))
}
minimalweeks <- 52 # Store the lowest common week for which we have data in the current year (2020)
"Function that aggregates deaths (as mean of years prior to 2020) as expected
data, and adds a column for excess deaths to the existing dataframe"
addExpectedDeaths <- function(df) {
weeks2020 <- weeksin2020(df)
if (weeks2020 <  minimalweeks) assign("minimalweeks", weeks2020,envir = .GlobalEnv) # Change global variable minimalweeks
expected_deaths <- df %>%
filter(year < 2020,
week <= weeks2020) %>%
group_by(gender,
agegroup,
week) %>%
summarise(deaths = as.integer(mean(deaths)))
new_df <- df %>%
filter(year == 2020) %>%
mutate(expected_deaths = expected_deaths$deaths,
excess_deaths = deaths - expected_deaths) %>%
select(gender,
agegroup,
year,
week,
country,
deaths,
expected_deaths,
excess_deaths)
return (new_df)
}
"Rowbind all datasets to a combined dataset, calling addExpectedDeaths()"
assembleAllData <- function(dfVector = c("data_norway",
"data_sweden",
"data_denmark",
"data_france",
"data_uk")) {
totaldata <- addExpectedDeaths(eval(as.name(dfVector[1])))
for (i in 2:length(dfVector)) {
totaldata <- rbind(totaldata,
addExpectedDeaths(eval(as.name(dfVector[i]))))
}
totaldata %<>% filter(week <= minimalweeks)
return (totaldata)
}
"Function that takes one data frame, set of agegroups, given genders by
default, one country, selfconstructed .pdf path to store the plot and
prefered y-axis interval. Much of the same description as for the
plotfunction_diff except from the fill-part. At the end it returns an
interactive plot which is facet wraped given by agegroup."
plotfunction <- function(df,
agevector = c("0-64", "65-79", "80-84", "85+"),
gendervector = c("M", "F"),
countryparam,
filename,
ymin = NA,
ymax = NA) {
plot <- df %>%
filter(agegroup %in% agevector,
gender %in% gendervector,
country %in% countryparam) %>%
ggplot() +
geom_smooth(aes(x = week,
y = deaths,
color = agegroup),
se = FALSE) +
geom_smooth(aes(x = week,
y = expected_deaths,
color = "Expected Deaths"),
fill = "lightblue") +
scale_color_viridis(discrete = TRUE) +
ylab("Deaths") +
xlab ("Weeks") +
ggtitle(paste("Expected vs. Actual Deaths in 2020",
"[", countryparam, "]")) +
theme_ipsum(base_family = "Helvetica",
plot_title_size = 12,
base_size = 14,
axis_title_size = 12)
if (!is.na(ymin) | !is.na(ymax)){
plot <- plot + ylim(ymin, ymax)
}
plot <- plot +
facet_wrap(~agegroup, nrow = 1) # Wraps number of agegroups on a single row
ggsave(paste("../results/", filename, sep = ""))
return (ggplotly(plot))           # ggplotly for interactivity
}
"Plots all the agegroups in a country in single plots"
plotter <- function(df, gender = c("M", "F"), country){
for (agegroup in levels(df$agegroup)){
print(plotfunction_diff(df,
agevector = agegroup,
gendervector = gender,
country = country))
}
}
"Stores created plots in pdf-file"
plot_pdf <- function(filename, plot){
pdf(paste("../results/",filename, sep=""), onefile = TRUE)
plotter(plot)
dev.off()
}
#### Total Data ----------------------------------------------------------------
"Totaldata is a dataframe which contains all the created data frames to
a consolidated data frame"
totaldata <- assembleAllData()
##### Test statistics-----------------------------------------------------------
"Is the difference in deaths and expected deaths statistically significant?"
"Function that conducts a two sided welch t.test to test whether 2020
deaths are statistically different than expected deaths. Compares x_mean and
y_mean to find out whether deaths are higher or lower. Tags the p.value along
with a string indicating whether it is above or below the estimated deaths, and
returns them as a list"
t_testFunc <- function(df,
agegroupvector = c("0-64", "65-79", "80-84", "85+"),
countryparam =? character ) {
testset <- df %>%
filter(country == countryparam,
agegroup %in% agegroupvector,
week >= 12) %>%
group_by(week) %>%
summarise(deaths = sum(deaths),
expected_deaths = sum(expected_deaths)) %>%
select(deaths,
expected_deaths)
t_test <- t.test(testset$deaths,
testset$expected_deaths,
alternative = "two.sided",
var.equal = FALSE)
# Determine whether the mean estimate mean deaths are higher or
# lower than the expected deaths
x_mean <- as.integer(t_test$estimate[1])
y_mean <- as.integer(t_test$estimate[2])
if (x_mean < y_mean) {return(list("Below", t_test$p.value)) }
else return(list("Above", t_test$p.value))
}
"Function that returns a string
Calls t_testFunc on a given country, uses totaldata as df as opposed to tabledata.
Returns a string based on the result from t_test_func."
tableTests <- function(country) {
test <- t_testFunc(totaldata,
agegroupvector = c("0-64", "65-79", "80-84", "85+"),
countryparam = country)
p.value <- test[[2]]
outputlist <- list(test[[1]], p.value)
if (p.value > 0.15) outputlist[[1]] <- "Normal"
else if (test[[1]] == "Above") {
if      (p.value < 0.025) outputlist[[1]] <- "Above ***"
else if (p.value < 0.05)  outputlist[[1]] <- "Above **"
else if (p.value < 0.15)  outputlist[[1]] <- "Above *"
}
else if (test[[1]] == "Below")  {
if      (p.value < 0.025) outputlist[[1]] <- "Below ***"
else if (p.value < 0.05)  outputlist[[1]] <- "Below **"
else if (p.value < 0.15)  outputlist[[1]] <- "Below *"
}
return (outputlist)
}
" Returns the first element of a list generated by tableTests func"
getTableTestFirst <- function(country) {
return (tableTests(country)[[1]])
}
getTableTestFirst <- Vectorize(getTableTestFirst)
" Returns the second element of a list generated by tableTests func"
getTableTestPvalue <- function(country) {
return (round(tableTests(country)[[2]], 4))
}
getTableTestPvalue <- Vectorize(getTableTestPvalue)
## Tables  ---------------------------------------------------------------------
totaldataFilter <- totaldata %>% filter(week >= 12)
shortTable_data <- totaldataFilter  %>%
group_by(country) %>%
summarise(excess_deaths = sum(excess_deaths)) %>%
## Max excess deaths per week
cbind(.,
totaldataFilter %>%
group_by(country, week) %>%
summarise(excess_deaths = sum(excess_deaths)) %>%
group_by(country) %>%
filter(excess_deaths == max(excess_deaths)) %>%
rename(max_deaths_perweek = excess_deaths )) %>%
select(-3) %>%
## Percentage above normal
cbind(.,
totaldataFilter %>% filter(week >= 12) %>%
group_by(country) %>%
summarise(percentage_above_normal = percent((
sum(deaths)/sum(expected_deaths)))) %>%
select(-country)) %>%
mutate(statistically_significant = getTableTestFirst(country),
p.value = getTableTestPvalue(country)) %>%
rename("Country"                          = country,
"Total Excess Deaths"              = excess_deaths,
"Highest Excess Deaths in a Week"  = max_deaths_perweek,
"Week: Highest Excess deaths"      = week,
"Percentage of Normal Deaths"      = percentage_above_normal,
"Statistically Significant"        = statistically_significant,
"P-value"                          = p.value)
"Function that returns shortTableData using the formattable package"
shortTable <- function() {
lightred = "#ff7f7f"
outputTable <- formattable(shortTable_data, list(
"Total Excess Deaths"              = color_tile("white", lightred),
"Highest Excess Deaths in a Week"  = color_bar(lightred),
"Percentage of Normal Deaths"      = color_bar(lightred),
"Statistically Significant"        =
formatter("span", style = x ~ ifelse(substring(x, 1, 5) == "Above",
style(color = "red",
font.weight = "bold"),
NA))))
return (outputTable)
}
"Function that returns a sortable table which contains weekly deaths, expected
deaths and excess deaths according to agegroup and gender"
longTable <- function() {
outputtable <- datatable(totaldata %>%
select(-year),
colnames = c("Gender",
"Agegroup",
"Week",
"Country",
"Deaths",
"Expected Deaths",
"Excess Deaths"),
filter = "top",
options = list(pageLength = 20, autoWidth = TRUE),
class = 'cell-border stripe'
)
return (outputtable)
}
save(shortTable, shortTable_data, file = "Shiny/data/tableData.Rda")
save(totaldata, file = "Shiny/data/totaldata.Rda")
View(totaldata)
>>>>>>> master
