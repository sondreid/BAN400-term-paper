shortTable_data <- totaldataFilter  %>%
group_by(country) %>%
summarise(excess_deaths = sum(excess_deaths)) %>%
## Max excess deaths per week
cbind(.,
totaldataFilter %>%
group_by(country, week) %>%
summarise(excess_deaths = sum(excess_deaths)) %>%
group_by(country) %>%
filter(excess_deaths == max(excess_deaths)) %>%
rename(max_deaths_perweek = excess_deaths )) %>%
select(-3) %>%
## Percentage above normal
cbind(.,
totaldataFilter %>% filter(week >= 12) %>%
group_by(country) %>%
summarise(percentage_above_normal = percent((
sum(deaths)/sum(expected_deaths)))) %>%
select(-country)) %>%
mutate(statistically_significant = getTableTestFirst(country),
p.value = getTableTestPvalue(country)) %>%
rename("Country"                          = country,
"Total Excess Deaths"              = excess_deaths,
"Highest Excess Deaths in a Week"  = max_deaths_perweek,
"Week: Highest Excess deaths"      = week,
"Percentage of Normal Deaths"      = percentage_above_normal,
"Statistically Significant"        = statistically_significant,
"P-value"                          = p.value)
longTable_data <- totaldata %>%
select(-year)
"Function that returns shortTableData using the formattable package"
shortTable <- function() {
lightred = "#ff7f7f"
outputTable <- formattable(shortTable_data, list(
"Total Excess Deaths"              = color_tile("white", lightred),
"Highest Excess Deaths in a Week"  = color_bar(lightred),
"Percentage of Normal Deaths"      = color_bar(lightred),
"Statistically Significant"        =
formatter("span", style = x ~ ifelse(substring(x, 1, 5) == "Above",
style(color = "red",
font.weight = "bold"),
NA))))
return (outputTable)
}
"Function that returns a sortable table which contains weekly deaths, expected
deaths and excess deaths according to agegroup and gender"
longTable <- function() {
outputtable <- datatable(longTable_data,
colnames = c("Gender",
"Agegroup",
"Week",
"Country",
"Deaths",
"Expected Deaths",
"Excess Deaths"),
filter = "top",
options = list(pageLength = 20, autoWidth = TRUE),
class = 'cell-border stripe'
)
return (outputtable)
}
###################### Data standardisation script ##########################
"Libraries "
library(readxl)
library(readr)
library(tidyverse)
library(magrittr)
library(types)
library(lubridate)
library(janitor)
library(docstring)
"In case of sourcing the retrieval file directly to this file"
source("data_retrieval.r")
getStandard <- function() {
#' Retrieve data standard excel sheet
#' @returns standard dataframe
return(read_csv("../datasett/Datastandard/data_standard.csv")) }
getFormat <- function(country) {
#' Returns the format file of a given country
#' @param country :
#' @returns new dataframe
path <- paste("../datasett/", country, "/") %>% gsub(" ", "",.)
formatFiles <- list.files(path = path,
pattern = "format",
full.names = TRUE)
ListofDF <- lapply(formatFiles, read_csv)
df <- bind_rows(ListofDF)
formatCorrectness(df) # Check for correctness
return (df)
}
formatCorrectness <- function(df) {
#' Checks correctness of format dataframe (imported as csv file)
#' @returns Error messsage if error found
colnames <- colnames(df)
if (!("Gender" %in% colnames) | !("Agegroups" %in% colnames) | !("AgeStandardGroup" %in% colnames)) {
stop("Format error: Missing one or more required columns")
}
if (length(which(!is.na(df$Agegroups))) != length(which(!is.na(df$AgeStandardGroup)))) {
stop("Format error: Missing values in agegroup or agegroupstandard")
}
}
#### Gender -----------------------------------------
standardiseGender <- function(df, country) {
#' In column gender, the function loops through all rows.
#' If it finds a match between the genderVector and standardGender it will return the standardGender
#' NA otherwise
#' @param df input dataframe
#' @param genderVec vector of original gender formatting in df
#' @returns a gender-standardized dataframe
standard <- getStandard() %>% filter(!is.na(Gender))
format <- getFormat(country) %>% filter(!is.na(Gender))
for (k in 1:nrow(df)) {
changedGender <- "No"
for (i in 1:length(format$Gender)) {
if (df$gender[k] == format$Gender[i]) {
df$gender[k] <- standard$Gender[i]
changedGender <- "Yes"
}
}
if (changedGender == "No") df$gender[k] <- NA
}
df <- df %>%
drop_na()
return (df)
}
#Test
sweden_gender <- standardiseGender(data_sweden, "Sweden")
norway_gender <- standardiseGender(data_norway, "Norway")
#### Age -------------------------------------------
getAge <- function(agestring, index) {
#' Function to convert a string og
#' @param agestring : string containing ages
#' @param index : index of the string to be returned e.g 2 -> returns "84" if agestring "80-84"
agestring <- (agestring %>%
strsplit(., "-"))[[1]] %>%
gsub("\\+", "", .)
if (length(agestring) == 1) return (agestring)
return (agestring[index])
}
ageToGroup <- function(df) {
#' Function to be used if the input dataframe does not have predetermined agegroups, but rather age as numeric valus.
#' Categorizes the dataframe ages as per defined in the standard format file
#' @param df : input dataframe
standard <- getStandard() %>% filter(!is.na(Agegroups))
for (k in 1:nrow(df)) {
for (i in 1:length(standard$Agegroups)) {
upperlimit <- getAge(standard$Agegroups[i], 2)
if (df$agegroup[k] <= upperlimit) {
df$agegroup[k] <- standard$Agegroups[i]
break
}
else if(i == length(standard$Agegroups)) df$agegroup[k] <- standard$Agegroups[i]
}
}
return (df)
}
standardiseAge <- function(df, country) {
#' Returns an age-standardised dataframe
#' We will end up with at the most the same number of unique agegroups, but if we end up with fewer,
#' a group_by -summarise operation is necessary to preserve the number of rows.
#'@param df : input dataframe
#'@param country: name of country to be standardised, string
#'@returns age-standardized dataframe
standard <- getStandard()
format <- getFormat(country)
if (format$Agegroups[1] == "Age") df <- ageToGroup(df)
else {
for (k in 1:nrow(df)) {
for (i in 1:length(format$Agegroups)) {
if (df$agegroup[k] == format$Agegroups[i]) {
standardIndex <-  format$AgeStandardGroup[i]
df$agegroup[k] <- standard$Agegroups[standardIndex]
}
}
}
}
df <-  df %>%
group_by(gender, agegroup,year,week) %>% #Preserve number of rows
summarise(deaths = sum(deaths),
country = country) %>% unique()
return (df)
}
############################################################################
standardiseCountry <- function(df, country) {
#' Standardizes a dataframe with regard to age and gender
#' @param df input dataframe
#' @param country name of country, string
df <- df %>%
standardiseGender(., country) %>%
standardiseAge(., country) %>%
drop_na() %>%
transform(gender = as.factor(gender),
agegroup = as.factor(agegroup),
week = as.numeric(week),
year = as.character(year),
deaths = as.numeric(deaths),
country = as.factor(country))
return (df)
}
# Data storage ------------------------------------------------------------------------
data_norway  %<>% standardiseCountry(., "Norway")
data_sweden  %<>% standardiseCountry(., "Sweden")
data_denmark %<>% standardiseCountry(., "Denmark")
data_uk      %<>% standardiseCountry(., "Denmark")
data_france  %<>% standardiseCountry(., "France")
"Saving the data frame to a .Rda-file for the purpose of analysis.r.
This is done for every data frames we have done in this file, the main purpose
is the the running time issue caused by large datasets, and this will reduce
the loading time significantly."
save(data_norway,data_sweden,data_denmark,data_uk,data_france, file = "../datasett/processed_data_all_countries.Rda")
setwd("/Users/olaiviken/OneDrive - Norges HandelshÃ¸yskole/MASTER/BAN400/Term paper/BAN400-term-paper/script")
######################### Data Analysis Script #################################
"Support for utf-8 encoding"
options(encoding="utf-8")
"Libraries for the analysis"
library(kableExtra)
library(tidyverse)
library(tidygraph)
library(hrbrthemes)
library(viridis)
library(dygraphs)
library(xts)
library(lubridate)
library(plotly)
library(types)
library(pdftools)
library(gt)
library(scales)
library(formattable)
library(DT)
"In case of sourcing the retrieval file directly to this file"
#source("standardisation.r")
"Loading data frames retrieved from standardisation.r"
load("../datasett/processed_data_all_countries.Rda")
#### Functions -----------------------------------------------------------------
"This is a function that takes a given data frame, single agegrouping, gender,
which by default is Male 'M' and Female 'F' and also given countries. The
mutation of min_reg and max_reg is done in order to fill the area inbetween
the actual and expected regression lines."
plotfunction_diff <- function(df,
agegrouping =? character,
gendervector = c("M", "F"),
countryparam) {
df <- df %>%
filter(agegroup == agegrouping,
gender %in% gendervector,
country == countryparam)
regline_fitted <- loess(df$deaths ~ df$week)
regline_expected <- loess(df$expected_deaths ~ df$week)
plot <- df %>%
mutate(min_reg = pmin(regline_fitted$fitted,
regline_expected$fitted),
max_reg = pmax(regline_fitted$fitted,
regline_expected$fitted)) %>%
ggplot() +
geom_smooth(aes(x = week,
y = deaths,
color = agegroup),
se = FALSE) +             # Confidence interval
geom_smooth(aes(x = week,
y = expected_deaths,
color = "Expected Deaths")) +
geom_ribbon(aes(week,
ymin = min_reg,
ymax = max_reg),
fill = "red",
alpha = 0.5) +
scale_color_viridis(discrete = TRUE) +
ylab("Deaths") +
xlab ("Weeks") +
ggtitle(paste("Expected vs. Actual Deaths in 2020",
"[", countryparam, "]",
"[Agegroup: ", agegrouping, "]")) +
theme_ipsum(base_family = "Helvetica",
plot_title_size = 12,
base_size = 14,
axis_title_size = 12)
return (ggplotly(plot)) # ggplotly for interactivity
}
"Function that finds the number of weeks we have data accounted for in 2020"
weeksin2020 <- function(df) {
return (nrow(df %>%
filter(year == 2020) %>%
select(week) %>%
unique()))
}
"Function that aggregates deaths (as mean of years prior to 2020) as expected
data, and adds a column for excess deaths to the existing dataframe"
addExpectedDeaths <- function(df) {
expected_deaths <- df %>%
filter(year < 2020,
week <= weeksin2020(df)) %>%
group_by(gender,
agegroup,
week) %>%
summarise(deaths = as.integer(mean(deaths)))
new_df <- df %>%
filter(year == 2020) %>%
mutate(expected_deaths = expected_deaths$deaths,
excess_deaths = deaths - expected_deaths) %>%
select(gender,
agegroup,
year,
week,
country,
deaths,
expected_deaths,
excess_deaths)
return (new_df)
}
#Tests
testDF <- addExpectedDeaths(data_norway)
"Rowbind all datasets to a combined dataset, calling addExpectedDeaths()"
assembleAllData <- function(dfVector = c("data_norway",
"data_sweden",
"data_denmark",
"data_france",
"data_uk")) {
totaldata <- addExpectedDeaths(eval(as.name(dfVector[1])))
for (i in 2:length(dfVector)) {
totaldata <- rbind(totaldata,
addExpectedDeaths(eval(as.name(dfVector[i]))))
}
return (totaldata)
}
"Function that takes one data frame, set of agegroups, given genders by
default, one country, selfconstructed .pdf path to store the plot and
prefered y-axis interval. Much of the same description as for the
plotfunction_diff except from the fill-part. At the end it returns an
interactive plot which is facet wraped given by agegroup."
plotfunction <- function(df,
agevector = c("0-64", "65-79", "80-84", "85+"),
gendervector = c("M", "F"),
countryparam,
filename,
ymin = NA,
ymax = NA) {
plot <- df %>%
filter(agegroup %in% agevector,
gender %in% gendervector,
country %in% countryparam) %>%
ggplot() +
geom_smooth(aes(x = week,
y = deaths,
color = agegroup),
se = FALSE) +
geom_smooth(aes(x = week,
y = expected_deaths,
color = "Expected Deaths"),
fill = "lightblue") +
scale_color_viridis(discrete = TRUE) +
ylab("Deaths") +
xlab ("Weeks") +
ggtitle(paste("Expected vs. Actual Deaths in 2020",
"[", countryparam, "]")) +
theme_ipsum(base_family = "Helvetica",
plot_title_size = 12,
base_size = 14,
axis_title_size = 12)
if (!is.na(ymin) | !is.na(ymax)){
plot <- plot + ylim(ymin, ymax)
}
plot <- plot +
facet_wrap(~agegroup, nrow = 1) # Wraps number of agegroups on a single row
ggsave(paste("../results/", filename))
return (ggplotly(plot))           # ggplotly for interactivity
}
"Plots all the agegroups in a country in single plots"
plotter <- function(df, gender = c("M", "F"), country){
for (agegroup in levels(df$agegroup)){
print(plotfunction_diff(df,
agevector = agegroup,
gendervector = gender,
country = country))
}
}
"Stores created plots in pdf-file"
plot_pdf <- function(filename, plot){
pdf(paste("../results/",filename), onefile = TRUE)
plotter(plot)
dev.off()
}
#### Total Data ----------------------------------------------------------------
"Totaldata is a dataframe which contains all the created data frames to
a consolidated data frame"
totaldata <- assembleAllData()
save(totaldata, file = "../script/Shiny/totaldata.Rda")
##### Test statistics-----------------------------------------------------------
"Is the difference in deaths and expected deaths statistically significant?"
"Function that conducts a two sided welch t.test to test whether 2020
deaths are statistically different than expected deaths. Compares x_mean and
y_mean to find out whether deaths are higher or lower. Tags the p.value along
with a string indicating whether it is above or below the estimated deaths, and
returns them as a list"
t_testFunc <- function(df,
agegroupvector = c("0-64", "65-79", "80-84", "85+"),
countryparam =? character ) {
testset <- df %>%
filter(country == countryparam,
agegroup %in% agegroupvector,
week >= 12) %>%
group_by(week) %>%
summarise(deaths = sum(deaths),
expected_deaths = sum(expected_deaths)) %>%
select(deaths,
expected_deaths)
t_test <- t.test(testset$deaths,
testset$expected_deaths,
alternative = "two.sided",
var.equal = FALSE)
# Determine whether the mean estimate mean deaths are higher or
# lower than the expected deaths
x_mean <- as.integer(t_test$estimate[1])
y_mean <- as.integer(t_test$estimate[2])
if (x_mean < y_mean) {return(list("Below", t_test$p.value)) }
else return(list("Above", t_test$p.value))
}
"Function that returns a string
Calls t_testFunc on a given country, uses totaldata as df as opposed to tabledata.
Returns a string based on the result from t_test_func."
tableTests <- function(country) {
test <- t_testFunc(totaldata,
agegroupvector = c("0-64", "65-79", "80-84", "85+"),
countryparam = country)
p.value <- test[[2]]
outputlist <- list(test[[1]], p.value)
if (p.value > 0.15) outputlist[[1]] <- "Normal"
else if (test[[1]] == "Above") {
if      (p.value < 0.025) outputlist[[1]] <- "Above ***"
else if (p.value < 0.05)  outputlist[[1]] <- "Above **"
else if (p.value < 0.15)  outputlist[[1]] <- "Above *"
}
else if (test[[1]] == "Below")  {
if      (p.value < 0.025) outputlist[[1]] <- "Below ***"
else if (p.value < 0.05)  outputlist[[1]] <- "Below **"
else if (p.value < 0.15)  outputlist[[1]] <- "Below *"
}
return (outputlist)
}
" Returns the first element of a list generated by tableTests func"
getTableTestFirst <- function(country) {
return (tableTests(country)[[1]])
}
getTableTestFirst <- Vectorize(getTableTestFirst)
" Returns the second element of a list generated by tableTests func"
getTableTestPvalue <- function(country) {
return (round(tableTests(country)[[2]], 4))
}
getTableTestPvalue <- Vectorize(getTableTestPvalue)
## Tables  ---------------------------------------------------------------------
totaldataFilter <- totaldata %>% filter(week >= 12)
shortTable_data <- totaldataFilter  %>%
group_by(country) %>%
summarise(excess_deaths = sum(excess_deaths)) %>%
## Max excess deaths per week
cbind(.,
totaldataFilter %>%
group_by(country, week) %>%
summarise(excess_deaths = sum(excess_deaths)) %>%
group_by(country) %>%
filter(excess_deaths == max(excess_deaths)) %>%
rename(max_deaths_perweek = excess_deaths )) %>%
select(-3) %>%
## Percentage above normal
cbind(.,
totaldataFilter %>% filter(week >= 12) %>%
group_by(country) %>%
summarise(percentage_above_normal = percent((
sum(deaths)/sum(expected_deaths)))) %>%
select(-country)) %>%
mutate(statistically_significant = getTableTestFirst(country),
p.value = getTableTestPvalue(country)) %>%
rename("Country"                          = country,
"Total Excess Deaths"              = excess_deaths,
"Highest Excess Deaths in a Week"  = max_deaths_perweek,
"Week: Highest Excess deaths"      = week,
"Percentage of Normal Deaths"      = percentage_above_normal,
"Statistically Significant"        = statistically_significant,
"P-value"                          = p.value)
longTable_data <- totaldata %>%
select(-year)
"Function that returns shortTableData using the formattable package"
shortTable <- function() {
lightred = "#ff7f7f"
outputTable <- formattable(shortTable_data, list(
"Total Excess Deaths"              = color_tile("white", lightred),
"Highest Excess Deaths in a Week"  = color_bar(lightred),
"Percentage of Normal Deaths"      = color_bar(lightred),
"Statistically Significant"        =
formatter("span", style = x ~ ifelse(substring(x, 1, 5) == "Above",
style(color = "red",
font.weight = "bold"),
NA))))
return (outputTable)
}
"Function that returns a sortable table which contains weekly deaths, expected
deaths and excess deaths according to agegroup and gender"
longTable <- function() {
outputtable <- datatable(longTable_data,
colnames = c("Gender",
"Agegroup",
"Week",
"Country",
"Deaths",
"Expected Deaths",
"Excess Deaths"),
filter = "top",
options = list(pageLength = 20, autoWidth = TRUE),
class = 'cell-border stripe'
)
return (outputtable)
}
