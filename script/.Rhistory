agegroup,
year,
week) %>%
summarise(deaths = sum(deaths)) %>%
ungroup() %>%                       # Ungroup such that mutation is allowed
mutate(country = "Denmark") %>%
transform(gender = as.factor(gender),
agegroup = as.factor(agegroup),
week = as.numeric(week),
year = as.numeric(year),
deaths = as.numeric(deaths),
country = as.factor(country))
"Saving the data frame to a .Rda-file for the purpose of analysis.r.
This is done for every data frames we have done in this file, the main purpose
is the the running time issue caused by large datasets, and this will reduce
the loading time significantly."
save(data_denmark, file = "../results/data_denmark.Rda")
#### Data UK ----------------------------------------------------------------
"UK datasets differ in the way they categorize age groups in the periods
2014-2019 and 2020. As a result of that getAgeVector transforms the agegroup
and returns the lower bound of the agegroup as a numeric value. The ageuniformiy
function then places the age in a fitting agegroup."
data_uk_2014 <- read_xls("../datasett/UK/UK_2014.xls",
sheet = "Weekly Figures 2014",
range = "A2:BA40") %>%
clean_data(.,                    # Function call to clean_data
2014,
selectColMale = c(1, 21, 23:29),
selectColFemale =  c(1, 30, 32:38))
data_uk_2015 <- read_xls("../datasett/UK/UK_2015.xls",
sheet = "Weekly Figures 2015",
range = "A3:BB40") %>%
clean_data(.,
2015,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2016 <- read_xls("../datasett/UK/UK_2016.xls",
sheet = "Weekly figures 2016",
range = "A3:BB40") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
clean_data(.,
2016,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2017 <- read_xls("../datasett/UK/UK_2017.xls",
sheet = "Weekly figures 2017",
range = "A3:BB40") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
clean_data(.,
2017,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2018 <- read_xls("../datasett/UK/UK_2018.xls",
sheet = "Weekly figures 2018",
range = "A3:BB40") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
clean_data(.,
2018,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2019 <- read_xls("../datasett/UK/UK_2019.xls",
sheet = "Weekly figures 2019",
range = "A3:BB40") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
clean_data(.,
2019,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2020 <- read_xlsx("../datasett/UK/UK_2020.xlsx",
sheet = "Weekly figures 2020",
range = "A4:AI85") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
custom_clean_data_2020(.,
2020,
selectColMale = c(1, 38, 40:59),
selectColFemale =  c(1, 60, 62:81)) %>%
mutate(agegroup = getAgeVector(agegroup),
agegroup = ageUniformityUKVector(agegroup))
# Binding all data frames created except from 2020
data_uk <- do.call("rbind", list(data_uk_2014,
data_uk_2015,
data_uk_2016,
data_uk_2017,
data_uk_2018,
data_uk_2019,
data_uk_2020)) %>%
mutate(gender = genderFunc_vector(gender),
agegroup = getAgeVector(agegroup),
agegroup = ageUniformityUKVector(agegroup),
agegroup = ageGroup_vector(agegroup)) %>%
select(gender,
agegroup,
year,
week ,
deaths,
country) %>%
group_by(gender,
agegroup,
year,
week) %>%
summarise(deaths = sum(deaths)) %>%
ungroup() %>%
mutate(country = "UK") %>%
transform(gender = as.factor(gender),
agegroup = as.factor(agegroup),
week = as.numeric(week),
year = as.numeric(year),
deaths = as.numeric(deaths),
country = as.factor(country))
"Saving the data frame to a .Rda-file for the purpose of analysis.r.
This is done for every data frames we have done in this file, the main purpose
is the the running time issue caused by large datasets, and this will reduce
the loading time significantly."
save(data_uk, file = "../results/data_uk.Rda")
# Removes unwanted df's
rm(data_uk_2014)
rm(data_uk_2015)
rm(data_uk_2016)
rm(data_uk_2017)
rm(data_uk_2018)
rm(data_uk_2019)
rm(data_uk_2020)
##### Data France -----------------------------------------------------------
"Gather csv filename from the France-folder in to a list"
datafiles_france <- list.files(path = "../datasett/France/",
pattern = "*.csv",
full.names = TRUE)
"Sapply() to read each file with read_csv2 with sep = ';',
then bind rows by id. The rest of the code does the cleaning"
data_france <- sapply(datafiles_france, read_csv2, simplify=FALSE) %>%
bind_rows(.id = "id") %>%
rename(day_dead = "JDEC",
month_dead = "MDEC",
year = "ADEC",
day_born = "JNAIS",
month_born = "MNAIS",
year_born = "ANAIS",
gender = "SEXE") %>%
transform(day_born = as.numeric(day_born),
month_born = as.numeric(month_born))  %>% # Replace missing values with NA
mutate(day_born = replace_na(day_born, 1), # Replace NA with 1
month_born = replace_na(month_born, 1),
date_born = ymd(paste(year_born, month_born, day_born)), ### Convert year month to single date of birth
date_dead = ymd(paste(year, month_dead, day_dead)),      ### Convert year month to single date of death
week = week(ymd(paste(year, month_dead, day_dead))),     ## Week of death
age = as.period(interval(date_born, date_dead), unit = "year")$year, ## Age at death
agegroup = ageGroup_vector(age)) %>%
filter(!is.na(agegroup)) %>%
group_by(gender,
agegroup,
year,
week) %>%
summarise(deaths = n()) %>%
ungroup() %>%
mutate(country = "France") %>%
transform(gender = as.factor(gender),
agegroup = as.factor(agegroup),
week = as.numeric(week),
year = as.numeric(year),
deaths = as.numeric(deaths),
country = as.factor(country))
save(data_france, file = "../results/data_france.Rda")
#### Remove functions that are no longer needed in memory ----------------------
rm(ageGroup)
rm(ageGroup_vector)
rm(ageUniformityUK)
rm(ageUniformityUKVector)
rm(changeNonRecurringRow)
rm(clean_data)
rm(custom_clean_data_2020)
rm(genderFunc)
rm(genderFunc_vector)
rm(getAge)
rm(getAgeVector)
rm(datafiles_france)
View(data_norway)
######################### Data Analysis Script #################################
"Support for utf-8 encoding"
options(encoding="utf-8")
"Libraries for the analysis"
library(kableExtra)
library(tidyverse)
library(tidygraph)
library(hrbrthemes)
library(viridis)
library(dygraphs)
library(xts)
library(lubridate)
library(plotly)
library(types)
library(pdftools)
library(gt)
library(scales)
library(formattable)
library(DT)
"In case of sourcing the retrieval file directly to this file"
#source("data_retrieval.r")
"Loading data frames retrieved from data_retrieval.r"
load("../results/data_norway.Rda")
load("../results/data_sweden.Rda")
load("../results/data_denmark.Rda")
load("../results/data_uk.Rda")
load("../results/data_france.Rda")
#### Functions -----------------------------------------------------------------
"This is a function that takes a given data frame, single agegrouping, gender,
which by default is Male 'M' and Female 'F' and also given countries. The
mutation of min_reg and max_reg is done in order to fill the area inbetween
the actual and expected regression lines."
plotfunction_diff <- function(df,
agegrouping =? character,
gendervector = c("M", "F"),
countryparam) {
df <- df %>%
filter(agegroup == agegrouping,
gender %in% gendervector,
country == countryparam)
regline_fitted <- loess(df$deaths ~ df$week)
regline_expected <- loess(df$expected_deaths ~ df$week)
plot <- df %>%
mutate(min_reg = pmin(regline_fitted$fitted,
regline_expected$fitted),
max_reg = pmax(regline_fitted$fitted,
regline_expected$fitted)) %>%
ggplot() +
geom_smooth(aes(x = week,
y = deaths,
color = agegroup),
se = FALSE) +             # Confidence interval
geom_smooth(aes(x = week,
y = expected_deaths,
color = "Expected Deaths")) +
geom_ribbon(aes(week,
ymin = min_reg,
ymax = max_reg),
fill = "red",
alpha = 0.5) +
scale_color_viridis(discrete = TRUE) +
ylab("Deaths") +
xlab ("Weeks") +
ggtitle(paste("Expected vs. Actual Deaths in 2020",
"[", countryparam, "]",
"[Agegroup: ", agegrouping, "]")) +
theme_ipsum(base_family = "Helvetica",
plot_title_size = 12,
base_size = 14,
axis_title_size = 12)
return (ggplotly(plot)) # ggplotly for interactivity
}
"Function that finds the number of weeks we have data accounted for in 2020"
weeksin2020 <- function(df) {
return (nrow(df %>%
filter(year == 2020) %>%
select(week) %>%
unique()))
}
"Function that aggregates deaths (as mean of years prior to 2020) as expected
data, and adds a column for excess deaths to the existing dataframe"
addExpectedDeaths <- function(df) {
expected_deaths <- df %>%
filter(year < 2020,
week <= weeksin2020(df)) %>%
group_by(gender,
agegroup,
week) %>%
summarise(deaths = as.integer(mean(deaths)))
new_df <- df %>%
filter(year == 2020) %>%
mutate(expected_deaths = expected_deaths$deaths,
excess_deaths = deaths - expected_deaths) %>%
select(gender,
agegroup,
year,
week,
country,
deaths,
expected_deaths,
excess_deaths)
return (new_df)
}
"Rowbind all datasets to a combined dataset, calling addExpectedDeaths()"
assembleAllData <- function(dfVector = c("data_norway",
"data_sweden",
"data_denmark",
"data_france",
"data_uk")) {
totaldata <- addExpectedDeaths(eval(as.name(dfVector[1])))
for (i in 2:length(dfVector)) {
totaldata <- rbind(totaldata,
addExpectedDeaths(eval(as.name(dfVector[i]))))
}
return (totaldata)
}
"Function that takes one data frame, set of agegroups, given genders by
default, one country, selfconstructed .pdf path to store the plot and
prefered y-axis interval. Much of the same description as for the
plotfunction_diff except from the fill-part. At the end it returns an
interactive plot which is facet wraped given by agegroup."
plotfunction <- function(df,
agevector = c("0-64", "65-79", "80-84", "85+"),
gendervector = c("M", "F"),
countryparam,
filename,
ymin = NA,
ymax = NA) {
plot <- df %>%
filter(agegroup %in% agevector,
gender %in% gendervector,
country %in% countryparam) %>%
ggplot() +
geom_smooth(aes(x = week,
y = deaths,
color = agegroup),
se = FALSE) +
geom_smooth(aes(x = week,
y = expected_deaths,
color = "Expected Deaths"),
fill = "lightblue") +
scale_color_viridis(discrete = TRUE) +
ylab("Deaths") +
xlab ("Weeks") +
ggtitle(paste("Expected vs. Actual Deaths in 2020",
"[", countryparam, "]")) +
theme_ipsum(base_family = "Helvetica",
plot_title_size = 12,
base_size = 14,
axis_title_size = 12)
if (!is.na(ymin) | !is.na(ymax)){
plot <- plot + ylim(ymin, ymax)
}
plot <- plot +
facet_wrap(~agegroup, nrow = 1) # Wraps number of agegroups on a single row
ggsave(paste("../results/", filename))
return (ggplotly(plot))           # ggplotly for interactivity
}
"Plots all the agegroups in a country in single plots"
plotter <- function(df, gender = c("M", "F"), country){
for (agegroup in levels(df$agegroup)){
print(plotfunction_diff(df,
agevector = agegroup,
gendervector = gender,
country = country))
}
}
"Stores created plots in pdf-file"
plot_pdf <- function(filename, plot){
pdf(paste("../results/",filename), onefile = TRUE)
plotter(plot)
dev.off()
}
#### Total Data ----------------------------------------------------------------
"Totaldata is a dataframe which contains all the created data frames to
a consolidated data frame"
totaldata <- assembleAllData()
##### Test statistics-----------------------------------------------------------
"Is the difference in deaths and expected deaths statistically significant?"
"Function that conducts a two sided welch t.test to test whether 2020
deaths are statistically different than expected deaths. Compares x_mean and
y_mean to find out whether deaths are higher or lower. Tags the p.value along
with a string indicating whether it is above or below the estimated deaths, and
returns them as a list"
t_testFunc <- function(df,
agegroupvector = c("0-64", "65-79", "80-84", "85+"),
countryparam =? character ) {
testset <- df %>%
filter(country == countryparam,
agegroup %in% agegroupvector,
week >= 12) %>%
group_by(week) %>%
summarise(deaths = sum(deaths),
expected_deaths = sum(expected_deaths)) %>%
select(deaths,
expected_deaths)
t_test <- t.test(testset$deaths,
testset$expected_deaths,
alternative = "two.sided",
var.equal = FALSE)
# Determine whether the mean estimate mean deaths are higher or
# lower than the expected deaths
x_mean <- as.integer(t_test$estimate[1])
y_mean <- as.integer(t_test$estimate[2])
if (x_mean < y_mean) {return(list("Below", t_test$p.value)) }
else return(list("Above", t_test$p.value))
}
"Function that returns a string
Calls t_testFunc on a given country, uses totaldata as df as opposed to tabledata.
Returns a string based on the result from t_test_func."
tableTests <- function(country) {
test <- t_testFunc(totaldata,
agegroupvector = c("0-64", "65-79", "80-84", "85+"),
countryparam = country)
p.value <- test[[2]]
outputlist <- list(test[[1]], p.value)
if (p.value > 0.15) outputlist[[1]] <- "Normal"
else if (test[[1]] == "Above") {
if      (p.value < 0.025) outputlist[[1]] <- "Above ***"
else if (p.value < 0.05)  outputlist[[1]] <- "Above **"
else if (p.value < 0.15)  outputlist[[1]] <- "Above *"
}
else if (test[[1]] == "Below")  {
if      (p.value < 0.025) outputlist[[1]] <- "Below ***"
else if (p.value < 0.05)  outputlist[[1]] <- "Below **"
else if (p.value < 0.15)  outputlist[[1]] <- "Below *"
}
return (outputlist)
}
" Returns the first element of a list generated by tableTests func"
getTableTestFirst <- function(country) {
return (tableTests(country)[[1]])
}
getTableTestFirst <- Vectorize(getTableTestFirst)
" Returns the second element of a list generated by tableTests func"
getTableTestPvalue <- function(country) {
return (round(tableTests(country)[[2]], 4))
}
getTableTestPvalue <- Vectorize(getTableTestPvalue)
## Tables  ---------------------------------------------------------------------
totaldataFilter <- totaldata %>% filter(week >= 12)
shortTable_data <- totaldataFilter  %>%
group_by(country) %>%
summarise(excess_deaths = sum(excess_deaths)) %>%
## Max excess deaths per week
cbind(.,
totaldataFilter %>%
group_by(country, week) %>%
summarise(excess_deaths = sum(excess_deaths)) %>%
group_by(country) %>%
filter(excess_deaths == max(excess_deaths)) %>%
rename(max_deaths_perweek = excess_deaths )) %>%
select(-3) %>%
## Percentage above normal
cbind(.,
totaldataFilter %>% filter(week >= 12) %>%
group_by(country) %>%
summarise(percentage_above_normal = percent((
sum(deaths)/sum(expected_deaths)))) %>%
select(-country)) %>%
mutate(statistically_significant = getTableTestFirst(country),
p.value = getTableTestPvalue(country)) %>%
rename("Country"                          = country,
"Total Excess Deaths"              = excess_deaths,
"Highest Excess Deaths in a Week"  = max_deaths_perweek,
"Week: Highest Excess deaths"      = week,
"Percentage of Normal Deaths"      = percentage_above_normal,
"Statistically Significant"        = statistically_significant,
"P-value"                          = p.value)
longTable_data <- totaldata %>%
select(-year)
"Function that returns shortTableData using the formattable package"
shortTable <- function() {
lightred = "#ff7f7f"
outputTable <- formattable(shortTable_data, list(
"Total Excess Deaths"              = color_tile("white", lightred),
"Highest Excess Deaths in a Week"  = color_bar(lightred),
"Percentage of Normal Deaths"      = color_bar(lightred),
"Statistically Significant"        =
formatter("span", style = x ~ ifelse(substring(x, 1, 5) == "Above",
style(color = "red",
font.weight = "bold"),
NA))))
return (outputTable)
}
"Function that returns a sortable table which contains weekly deaths, expected
deaths and excess deaths according to agegroup and gender"
longTable <- function() {
outputtable <- datatable(longTable_data,
colnames = c("Gender",
"Agegroup",
"Week",
"Country",
"Deaths",
"Expected Deaths",
"Excess Deaths"),
filter = "top",
options = list(pageLength = 20, autoWidth = TRUE),
class = 'cell-border stripe'
)
return (outputtable)
}
totaldata %>% filter(country == "UK") %>% group_by(week, gender) %>% summarise(deaths = sum(deahts), expected_deaths = sum(expected_deaths))
totaldata %>% filter(country == "UK") %>% group_by(week, gender) %>% summarise(deaths = sum(deaths), expected_deaths = sum(expected_deaths))
totaldata %>% filter(country == "UK") %>% group_by(week, agegroup) %>% summarise(deaths = sum(deaths), expected_deaths = sum(expected_deaths))
totaldata %>% filter(country == "UK") %>% group_by(week, agegroup) %>% summarise(deaths = sum(deaths), expected_deaths = sum(expected_deaths)) %>% mutate(maxdeath = max(deaths))
data_norway <- read_excel("../datasett/norway_ssb.xlsx",
range = "Dode1!a4:X1594")
"Libraries for retrieval and cleaning"
library(readxl)
library(readr)
library(tidyverse)
library(types)
library(lubridate)
library(janitor)
#### Functions -------------
"Reading excel file with given range of rows and columns"
data_norway <- read_excel("../datasett/norway_ssb.xlsx",
range = "Dode1!a4:X1594")
View(data_norway)
data_sweden <-
read_excel("../datasett/sweden_scb.xlsx",
sheet = "Tabell 7",
range = "Tabell 7!a9:s62")
View(data_sweden)
read_csv2."
data_denmark <- read_delim("../datasett/danmark_statbank_2013-2020.csv",
delim = ";",
skip = 2)
data_denmark <- read_delim("../datasett/danmark_statbank_2013-2020.csv",
delim = ";",
skip = 2)
View(data_denmark)
data_norway <- read_excel("../datasett/norway_ssb.xlsx",
range = "Dode1!a4:X1594")
View(data_norway)
