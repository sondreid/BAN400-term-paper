load("Shiny/data/totaldata.Rda")
#### Data selection --------------------------------------------
aggregateColumn <- function(df = totaldata,
column) {
#' Function that aggregates a column of an input dataframe by grouping all columns except the chosen column
#' @param df: input dataframe, per default totaldata
#' @param column: column to be aggregated
#' @return : a modified dataframe
columns <- c("week", "country", "gender", "agegroup")
columns %<>% setdiff(., column)
print(columns)
df %<>%
group_by_at(columns) %>%
summarise(
deaths = sum(deaths),
excess_deaths = sum(excess_deaths)) %>%
mutate(!!column := "All")
return (df)
}
totaldata %<>%
transform(
country = as.factor(country),
year   = as.factor(year),
week = as.factor(week)) %>%
select(week, country, gender, agegroup, deaths, excess_deaths) %>%
rbind(., totaldata %>%  ## Add aggregate for gender and agegroup (deaths and excess deaths for all genders and agegroups for a week)
group_by(country, week) %>%
summarise(gender = "All", agegroup = "All", deaths = sum(deaths), excess_deaths = sum(excess_deaths))) %>%
rbind(., aggregateColumn(df = totaldata, "agegroup")) %>%
rbind(., aggregateColumn(df = totaldata, "gender"))
forecastData <- totaldata # Store totaldata with week feature
totaldata %<>% #Keep totaldata as ML prediction dataframe, but without week feature
select(-week)
intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
# Splitting data ---------------------------------------------
training_data <- totaldata[intrain,] #%>% select(excess_deaths,week)
test_data     <- totaldata[-intrain,]
## Model creation -----------------------------------------
#Make clusters
cl <- makePSOCKcluster(detectCores())
registerDoParallel(cl)
#
linnearreg <- train(excess_deaths ~ deaths,
data = training_data,
method = "lm")
control <- trainControl(method = "repeatedcv",
n = 15,
repeats = 10)
RFmodel <- train(excess_deaths ~.,
data = training_data,
method = "rf",
metric = "RMSE",
trcontrol = control)
SVMmodel <- train(excess_deaths ~.,
data = training_data,
method = "svmPoly",
metric = "RMSE",
trcontrol = control,
tunelength = 4)
SVMRadialmodel <- train(excess_deaths ~.,
data = training_data,
method = "svmRadial",
metric = "RMSE",
trcontrol = control,
tunelength = 4)
#Print relevant statistics
print(linnearreg)
summary(linnearreg)
## RF model
print(RFmodel)
##SVM model
print(SVMmodel)
print(SVMRadialmodel)
stopCluster(cl) #Stop cluster
### Evaluation -----------------------------------------------------------------------
modelList <- list(SVMmodel, RFmodel, SVMRadialmodel)
evaluateModels <- function(modelList, testData, feature) {
#' Returns the best fitted model based on RMSE ( )
#'@param modelList: list of potential models
bestRMSE <- Inf
bestModel <- modelList[1]
for (model in modelList) {
prediction <- predict(model, newdata = testData)
RMSE <- postResample(pred = prediction, obs = testData[[feature]])[[1]]
if (RMSE < bestRMSE) {
bestRMSE <- RMSE
bestModel <- model
}
}
return (bestModel)
}
bestModel <- evaluateModels(modelList, test_data, "excess_deaths")
print(bestModel)
predict(linearreg, test_data)
rfPrediction <- predict(RFmodel, newdata = test_data)
svmPrediction <- predict(SVMmodel, newdata = test_data)
bestPred <- predict(bestModel, newdata = test_data)
postResample(pred = rfPrediction, obs = test_data$excess_deaths) #Evaluate
#### Forecast ----------------------------------------------------
cl <- makePSOCKcluster(detectCores())
registerDoParallel(cl)
date_frequency <- "1 week"
outcome_column <- 6
forecast_intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
forecast_train_data <- forecastData[forecast_intrain]
forecast_test_data <-  forecastData[-forecast_intrain]
forecast_data_list <- create_lagged_df(forecastData,
type = "train",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
horizons = 1:10,
#groups?
dynamic_features ="law")
windows <- create_windows(lagged_df = forecast_data_list,
window_length = 1)
model_function <- function(data) {
#'
outcome_names <- names(data)[outcome_column]
#print(paste("outcome names", outcome_names))
model_formula <- formula(paste0(outcome_names,  "~ ."))
# print(paste("formula:", model_formula))
model <- randomForest::randomForest(model_formula, data = data, ntree = 10)
return(model)
}
forecast_model <- forecastML::train_model(forecast_data_list, windows, model_name = "RF",
model_function, use_future = FALSE)
#pred <- predict(forecast_model, newdata = forecast_test_data)
pred_function <- function(model, data_features) {
data_pred <- data.frame("y_pred" = predict(model, data_features))
return(data_pred)
}
data_results <- predict(forecast_model,
prediction_function = list(pred_function),
data = forecast_data_list)
stopCluster(cl) #Stop cluster
cl <- makePSOCKcluster(detectCores())
registerDoParallel(cl)
date_frequency <- "1 week"
outcome_column <- 6
forecast_intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
forecast_train_data <- forecastData[forecast_intrain]
forecast_test_data <-  forecastData[-forecast_intrain]
forecast_data_list <- create_lagged_df(forecastData,
type = "train",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
horizons = 1:10,
#groups?
dynamic_features ="law")
windows <- create_windows(lagged_df = forecast_data_list,
window_length = 1)
cl <- makePSOCKcluster(detectCores())
registerDoParallel(cl)
date_frequency <- "1 week"
outcome_column <- 6
forecast_intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
forecast_train_data <- forecastData[forecast_intrain]
forecast_test_data <-  forecastData[-forecast_intrain]
forecast_data_list <- create_lagged_df(forecast_train_data,
type = "train",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
horizons = 1:10,
#groups?
dynamic_features ="law")
windows <- create_windows(lagged_df = forecast_data_list,
window_length = 0)
registerDoParallel(cl)
date_frequency <- "1 week"
outcome_column <- 6
forecast_intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
forecast_train_data <- forecastData[forecast_intrain]
forecast_test_data <-  forecastData[-forecast_intrain]
date_frequency <- "1 week"
outcome_column <- 6
forecast_intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
forecast_train_data <- forecastData[forecast_intrain,]
forecast_test_data <-  forecastData[-forecast_intrain,]
View(forecast_train_data)
forecast_data_list <- create_lagged_df(forecast_train_data,
type = "train",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
horizons = 1:10,
#groups?
dynamic_features ="law")
windows <- create_windows(lagged_df = forecast_data_list,
window_length = 0)
model_function <- function(data) {
#'
#outcome_names <- names(data)[outcome_column]
#print(paste("outcome names", outcome_names))
#model_formula <- formula(paste0(outcome_names,  "~ ."))
# print(paste("formula:", model_formula))
model <- randomForest::randomForest(excess_deaths ~., data = data, ntree = 10)
return(model)
}
forecast_model <- forecastML::train_model(forecast_data_list, windows, model_name = "RF",
model_function, use_future = FALSE)
pred_function <- function(model, data_features) {
data_pred <- data.frame("y_pred" = predict(model, data_features))
return(data_pred)
}
data_results <- predict(forecast_model,
prediction_function = list(pred_function),
data = forecast_data_list)
data_results
date_frequency <- "1 week"
outcome_column <- 6
forecast_intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
forecast_train_data <- forecastData[forecast_intrain,]
forecast_test_data <-  forecastData[-forecast_intrain,]
forecast_data_list <- create_lagged_df(forecastData,
type = "forecast",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
horizons = 1:10,
#groups?
dynamic_features ="law")
windows <- create_windows(lagged_df = forecast_data_list,
window_length = 0)
model_function <- function(data) {
#'
#outcome_names <- names(data)[outcome_column]
#print(paste("outcome names", outcome_names))
#model_formula <- formula(paste0(outcome_names,  "~ ."))
# print(paste("formula:", model_formula))
model <- randomForest::randomForest(excess_deaths ~., data = data, ntree = 10)
return(model)
}
forecast_model <- forecastML::train_model(forecast_data_list, windows, model_name = "RF",
model_function, use_future = TRUE)
#pred <- predict(forecast_model, newdata = forecast_test_data)
pred_function <- function(model, data_features) {
data_pred <- data.frame("y_pred" = predict(model, data_features))
return(data_pred)
}
data_results <- predict(forecast_model,
prediction_function = list(pred_function),
data = forecast_data_list)
date_frequency <- "1 week"
outcome_column <- 6
forecast_intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
forecast_train_data <- forecastData[forecast_intrain,]
forecast_test_data <-  forecastData[-forecast_intrain,]
forecast_data_list <- create_lagged_df(forecastData,
type = "train",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
horizons = 1:10,
#groups?
dynamic_features ="law")
windows <- create_windows(lagged_df = forecast_data_list,
window_length = 0)
model_function <- function(data) {
#'
#outcome_names <- names(data)[outcome_column]
#print(paste("outcome names", outcome_names))
#model_formula <- formula(paste0(outcome_names,  "~ ."))
# print(paste("formula:", model_formula))
model <- randomForest::randomForest(excess_deaths ~., data = data, ntree = 10)
return(model)
}
forecast_model <- forecastML::train_model(forecast_data_list, windows, model_name = "RF",
model_function, use_future = FALSE)
#pred <- predict(forecast_model, newdata = forecast_test_data)
pred_function <- function(model, data_features) {
data_pred <- data.frame("y_pred" = predict(model, data_features))
return(data_pred)
}
data_results <- predict(forecast_model,
prediction_function = list(pred_function),
data = forecast_data_list)
date_frequency <- "1 week"
outcome_column <- 6
forecast_intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
forecast_train_data <- forecastData[forecast_intrain,]
forecast_test_data <-  forecastData[-forecast_intrain,]
forecast_data_list <- create_lagged_df(forecastData,
type = "forecast",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
horizons = 1:10,
#groups?
dynamic_features ="law")
windows <- create_windows(lagged_df = forecast_data_list,
window_length = 0)
model_function <- function(data) {
#'
#outcome_names <- names(data)[outcome_column]
#print(paste("outcome names", outcome_names))
#model_formula <- formula(paste0(outcome_names,  "~ ."))
# print(paste("formula:", model_formula))
model <- randomForest::randomForest(excess_deaths ~., data = data, ntree = 10)
return(model)
}
forecast_model <- forecastML::train_model(forecast_data_list, windows, model_name = "RF",
model_function, use_future = FALSE)
#pred <- predict(forecast_model, newdata = forecast_test_data)
pred_function <- function(model, data_features) {
data_pred <- data.frame("y_pred" = predict(model, data_features))
return(data_pred)
}
data_results <- predict(forecast_model,
prediction_function = list(pred_function),
data = forecast_data_list)
date_frequency <- "1 week"
outcome_column <- 6
forecast_intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
forecast_train_data <- forecastData[forecast_intrain,]
forecast_test_data <-  forecastData[-forecast_intrain,]
forecast_data_list <- create_lagged_df(forecastData,
type = "forecast",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
horizons = 1:10
#groups?
#dynamic_features ="law")
windows <- create_windows(lagged_df = forecast_data_list,
window_length = 0)
model_function <- function(data) {
#'
#outcome_names <- names(data)[outcome_column]
#print(paste("outcome names", outcome_names))
#model_formula <- formula(paste0(outcome_names,  "~ ."))
# print(paste("formula:", model_formula))
model <- randomForest::randomForest(excess_deaths ~., data = data, ntree = 10)
return(model)
}
forecast_model <- forecastML::train_model(forecast_data_list, windows, model_name = "RF",
model_function, use_future = FALSE)
#pred <- predict(forecast_model, newdata = forecast_test_data)
pred_function <- function(model, data_features) {
data_pred <- data.frame("y_pred" = predict(model, data_features))
return(data_pred)
}
data_results <- predict(forecast_model,
prediction_function = list(pred_function),
data = forecast_data_list)
date_frequency <- "1 week"
outcome_column <- 6
forecast_intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
forecast_train_data <- forecastData[forecast_intrain,]
forecast_test_data <-  forecastData[-forecast_intrain,]
forecast_data_list <- create_lagged_df(forecastData,
type = "forecast",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
horizons = 1:10)
windows <- create_windows(lagged_df = forecast_data_list,
window_length = 0)
model_function <- function(data) {
#'
#outcome_names <- names(data)[outcome_column]
#print(paste("outcome names", outcome_names))
#model_formula <- formula(paste0(outcome_names,  "~ ."))
# print(paste("formula:", model_formula))
model <- randomForest::randomForest(excess_deaths ~., data = data, ntree = 10)
return(model)
}
forecast_model <- forecastML::train_model(forecast_data_list, windows, model_name = "RF",
model_function, use_future = FALSE)
#pred <- predict(forecast_model, newdata = forecast_test_data)
pred_function <- function(model, data_features) {
data_pred <- data.frame("y_pred" = predict(model, data_features))
return(data_pred)
}
data_results <- predict(forecast_model,
prediction_function = list(pred_function),
data = forecast_data_list)
date_frequency <- "1 week"
outcome_column <- 6
forecast_intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
forecast_train_data <- forecastData[forecast_intrain,]
forecast_test_data <-  forecastData[-forecast_intrain,]
forecast_data_list <- create_lagged_df(forecastData,
type = "train",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
horizons = 1:10,
#groups?
dynamic_features ="law")
windows <- create_windows(lagged_df = forecast_data_list,
window_length = 0)
model_function <- function(data) {
#'
#outcome_names <- names(data)[outcome_column]
#print(paste("outcome names", outcome_names))
#model_formula <- formula(paste0(outcome_names,  "~ ."))
# print(paste("formula:", model_formula))
model <- randomForest::randomForest(excess_deaths ~., data = data, ntree = 10)
return(model)
}
forecast_model <- forecastML::train_model(forecast_data_list, windows, model_name = "RF",
model_function, use_future = FALSE)
#pred <- predict(forecast_model, newdata = forecast_test_data)
pred_function <- function(model, data_features) {
data_pred <- data.frame("y_pred" = predict(model, data_features))
return(data_pred)
}
data_results <- predict(forecast_model,
prediction_function = list(pred_function),
data = forecast_data_list)
forecast_data <- create_lagged_df(forecastData,
type = "forecast",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
horizons = 1:10)
data_forecasts <- predict(model_results, prediction_function = list(pred_function), data = data_forecast)
data_forecasts <- predict(forecast_model, prediction_function = list(pred_function), data = data_forecast)
data_forecast <- create_lagged_df(forecastData,
type = "forecast",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
horizons = 1:10)
data_forecasts <- predict(forecast_model, prediction_function = list(pred_function), data = data_forecast)
#Combine results
data_forecasts <- forecastML::combine_forecasts(data_forecasts)
View(data_forecast)
data_forecasts <- forecastML::calculate_intervals(data_forecasts, residuals,
levels = seq(.5, .95, .05), times = 200)
plot(data_forecasts, forecastData[-(1:50), ], (1:nrow(data_seatbelts))[-(1:50)], interval_alpha = seq(.1, .2, length.out = 10))
residuals <- residuals(data_results)
data_forecasts <- forecastML::calculate_intervals(data_forecasts, residuals,
levels = seq(.5, .95, .05), times = 200)
data_forecasts$excess_deaths_pred
data_forecasts$excess_deaths_pred <- round(data_forecasts$excess_deaths_pred, 0)
DT::datatable(head(data_forecast, 10), options = list(scrollX = TRUE))
DT::datatable(head(data_forecast, 5), options = list(scrollX = TRUE))
as.Date("1984-12-01")
Mont("1984-12-01")
Month("1984-12-01")
month("1984-12-01")
library(lubridate)
month("1984-12-01")
DT::datatable(head(data_forecasts, 5), options = list(scrollX = TRUE))
dates[1:nrow(forecastData)]
1:nrow(forecastData$week)
1:nrow(forecastData$week)
1:nrow(forecastData)
dates <- seq(as.Date("1969-01-01"), as.Date("1984-12-01"), by = date_frequency)
dates
data_forecast <- create_lagged_df(forecastData,
type = "forecast",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
date = 1:nrow(forecastData$week),
frequency = 1,
horizons = 1:10)
DT::datatable(head(data_forecasts, 5), options = list(scrollX = TRUE))
data_forecasts <- predict(forecast_model, prediction_function = list(pred_function), data = forecastData)
data_forecast <- create_lagged_df(forecastData,
type = "forecast",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
frequency = 1,
horizons = 1:10)
data_forecasts <- predict(forecast_model, prediction_function = list(pred_function), data = data_forecast)
data_forecast <- create_lagged_df(forecastData,
type = "forecast",
method = "direct",
outcome_col = outcome_column,
lookback = 1:15,
frequency = "week",
horizons = 1:10)
data_forecasts <- predict(forecast_model, prediction_function = list(pred_function), data = data_forecast)
#Combine results
data_forecasts <- forecastML::combine_forecasts(data_forecasts)
data_forecasts <- forecastML::calculate_intervals(data_forecasts, residuals,
levels = seq(.5, .95, .05), times = 200)
data_forecasts$excess_deaths_pred <- round(data_forecasts$excess_deaths_pred, 0)
DT::datatable(head(data_forecasts, 5), options = list(scrollX = TRUE))
DT::datatable(head(data_forecasts, 10), options = list(scrollX = TRUE))
help("plot")
