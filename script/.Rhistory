model$results %>%
arrange(desc(Accuracy)) %>%
head(10)
}
accuracyModel(RFmodel)
cl <- makePSOCKcluster(10)
registerDoParallel(cl)
RFmodel <- train(excess_deaths ~.,
data = training_data,
method = "rf",
metric       = "Accuracy")
summary(RFmodel)
print(RFmodel)
print(linearreg)
linnearreg <- train(excess_deaths ~ week,
data = training_data,
method = "lm")
print(linearreg)
print(linnearreg)
summary(linearreg)
predict(RFmodel, test_data)
View(test_data)
######################### ML script/prediction script #################################
"Support for utf-8 encoding"
options(encoding="utf-8")
"Libraries"
library(caret)
library(dplyr)
library(magrittr)
library(gbm)
library(docstring)
library(doParallel)
"Loading data frames retrieved from standardisation.r"
load("../datasett/processed_data_all_countries.Rda")
"load totaldata"
load("Shiny/data/totaldata.Rda")
aggregateAgegroup <- function() {
totaldata %<>%
transform(week = as.factor(week),
country = as.factor(country),
year   = as.factor(year)) %>%
group_by(week, year, gender, country) %>%
summarise(deaths = sum(deaths),
expected_deaths = sum(expected_deaths),
excess_deaths = sum(excess_deaths))
}
totaldata %<>%
transform(week = as.factor(week),
country = as.factor(country),
year   = as.factor(year)) %>%
select(country, week, gender, agegroups deaths, excess_deaths)
intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
training_data <- totaldata[intrain,] #%>% select(excess_deaths,week)
test_data     <- totaldata[-intrain,]
.f <- function() {
gbmModel <- train(excess_deaths ~.,
distribution = "bernoulli",
data = training_data,
n.trees = 500,
interaction.depth = 4,
shrinkage = 0.01)
}
## Make a model
linnearreg <- train(excess_deaths ~ week,
data = training_data,
method = "lm")
cl <- makePSOCKcluster(10)
registerDoParallel(cl)
RFmodel <- train(excess_deaths ~.,
data = training_data,
method = "rf")
######################### ML script/prediction script #################################
"Support for utf-8 encoding"
options(encoding="utf-8")
"Libraries"
library(caret)
library(dplyr)
library(magrittr)
library(gbm)
library(docstring)
library(doParallel)
"Loading data frames retrieved from standardisation.r"
load("../datasett/processed_data_all_countries.Rda")
"load totaldata"
load("Shiny/data/totaldata.Rda")
aggregateAgegroup <- function() {
totaldata %<>%
transform(week = as.factor(week),
country = as.factor(country),
year   = as.factor(year)) %>%
group_by(week, year, gender, country) %>%
summarise(deaths = sum(deaths),
expected_deaths = sum(expected_deaths),
excess_deaths = sum(excess_deaths))
}
totaldata %<>%
transform(week = as.factor(week),
country = as.factor(country),
year   = as.factor(year)) %>%
select(country, week, gender, agegroups, deaths, excess_deaths)
######################### ML script/prediction script #################################
"Support for utf-8 encoding"
options(encoding="utf-8")
"Libraries"
library(caret)
library(dplyr)
library(magrittr)
library(gbm)
library(docstring)
library(doParallel)
"Loading data frames retrieved from standardisation.r"
load("../datasett/processed_data_all_countries.Rda")
"load totaldata"
load("Shiny/data/totaldata.Rda")
aggregateAgegroup <- function() {
totaldata %<>%
transform(week = as.factor(week),
country = as.factor(country),
year   = as.factor(year)) %>%
group_by(week, year, gender, country) %>%
summarise(deaths = sum(deaths),
expected_deaths = sum(expected_deaths),
excess_deaths = sum(excess_deaths))
}
totaldata %<>%
transform(week = as.factor(week),
country = as.factor(country),
year   = as.factor(year)) %>%
select(country, week, gender, agegroup, deaths, excess_deaths)
intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
training_data <- totaldata[intrain,] #%>% select(excess_deaths,week)
test_data     <- totaldata[-intrain,]
linnearreg <- train(excess_deaths ~ week,
data = training_data,
method = "lm")
cl <- makePSOCKcluster(10)
registerDoParallel(cl)
RFmodel <- train(excess_deaths ~.,
data = training_data,
method = "rf")
print(linnearreg)
summary(linnearreg)
print(RFmodel)
######################### ML script/prediction script #################################
"Support for utf-8 encoding"
options(encoding="utf-8")
"Libraries"
library(caret)
library(dplyr)
library(magrittr)
library(gbm)
library(docstring)
library(doParallel)
"Loading data frames retrieved from standardisation.r"
load("../datasett/processed_data_all_countries.Rda")
"load totaldata"
load("Shiny/data/totaldata.Rda")
aggregateAgegroup <- function() {
totaldata %<>%
transform(week = as.factor(week),
country = as.factor(country),
year   = as.factor(year)) %>%
group_by(week, year, gender, country) %>%
summarise(deaths = sum(deaths),
expected_deaths = sum(expected_deaths),
excess_deaths = sum(excess_deaths))
}
totaldata %<>%
transform(week = as.factor(week),
country = as.factor(country),
year   = as.factor(year)) %>%
select(country, week, gender, agegroup, deaths, excess_deaths)
intrain <- createDataPartition(y = totaldata$excess_deaths,
p = 0.8,
list = FALSE)
training_data <- totaldata[intrain,] #%>% select(excess_deaths,week)
test_data     <- totaldata[-intrain,]
.f <- function() {
gbmModel <- train(excess_deaths ~.,
distribution = "bernoulli",
data = training_data,
n.trees = 500,
interaction.depth = 4,
shrinkage = 0.01)
}
## Make a model-----------------------------------------
linnearreg <- train(excess_deaths ~ week,
data = training_data,
method = "lm")
cl <- makePSOCKcluster(detectCores())
registerDoParallel(cl)
RFmodel <- train(excess_deaths ~.,
data = training_data,
method = "rf")
print(linnearreg)
summary(linnearreg)
print(RFmodel)
shiny::runApp('Shiny')
runApp('Shiny')
runApp()
library(shiny)
library(ggplot2)
library(rsconnect)
# Partners libriaries
library(rsconnect)
library(kableExtra)
library(tidyverse)
library(tidygraph)
library(hrbrthemes)
library(viridis)
library(dygraphs)
library(xts)
library(lubridate)
library(plotly)
library(types)
library(pdftools)
library(gt)
library(scales)
library(formattable)
library(DT)
load(file = "data/totaldata.Rda")
load(file = "data/longTable_data.Rda")
source("ui.r")
server <- function(input, output) {
#observeEvent(input$clicks, {
#  print(as.numeric(input$clicks))
#})
#observe({print(input$clicks)})
data <- reactive({
totaldata[totaldata$week >= input$week[1] & totaldata$week <= input$week[2] & totaldata$country %in% input$countries,]
})
# Partners
rda <- reactive({
load(file="data/longTable_data.Rda")
})
# Partners
output$tableALL  <- DT :: renderDataTable({
load(file="data/longTable_data.Rda")
datatable(data = longTable_data,
colnames = c("Gender",
"Agegroup",
"Week",
"Country",
"Deaths",
"Expected Deaths",
"Excess Deaths"),
filter = "top",
options = list(pageLength = 5, autoWidth = 5, lengthMenu = 5, scrollX = T,
initComplete = JS(
"function(settings, json) {",
"$(this.api().table().header()).css({'background-color': '#517fb9', 'color': '#fff'});",
"}")),
class = 'cell-border stripe')
#longTable(5, TRUE, c(5, 10, 15, 20, 50, 100, 200, 500))}
})
# Partners
output$ggplotTable <- renderPlot ({
longTable_data_selection <- longTable_data[, c("week", "excess_deaths")] # Plot selection data
s1 <- input$tableALL_rows_all  # All filtered rows
df1 <- longTable_data_selection
if (length(s1)) {
df2 <- longTable_data_selection[s1, , drop = FALSE]
dat <- rbind(df1, df2)
dat$Group <- rep(factor(c("Original data", "Filtered data")),times = c(nrow(df1),nrow(df2)))
}
else {
dat <- df1
dat$Group <- rep("Original data", times = nrow(df1))
}
cols = c("Firebrick")
plot <- dat %>%
ggplot() +
geom_smooth(aes(x = week,
y = excess_deaths,
colour = Group)) +
labs(x = "Weeks", y = "Excess deaths") +
theme(plot.background=element_rect()) +
ggtitle("Filtered plot")
ggplotly(plot)
})
output$plot <- renderPlot({
p <- ggplot(data(), aes_string(x=input$x, y=input$y))
if (input$color != 'None')
p <- p + aes_string(color=input$color)
facets <- paste(input$facet_row, '~', input$facet_col)
if (facets != '. ~ .')
p <- p + facet_grid(facets)
if (input$jitter)
p <- p + geom_jitter()
if (input$smooth)
p <- p + geom_smooth()
if (input$actual)
p <- p + geom_point()
if (input$expected)
p <- p + geom_smooth(data = data(),
aes(x = week, y = expected_deaths))
print(p)
}, height=700)
}
# Remove comment for live test
#shinyApp(ui, server)
runApp('Shiny')
library(shiny)
library(ggplot2)
library(rsconnect)
# Partners libriaries
library(rsconnect)
library(kableExtra)
library(tidyverse)
library(tidygraph)
library(hrbrthemes)
library(viridis)
library(dygraphs)
library(xts)
library(lubridate)
library(plotly)
library(types)
library(pdftools)
library(gt)
library(scales)
library(formattable)
library(DT)
load(file = "data/totaldata.Rda")
load(file = "data/longTable_data.Rda")
source("ui.r")
server <- function(input, output) {
#observeEvent(input$clicks, {
#  print(as.numeric(input$clicks))
#})
#observe({print(input$clicks)})
data <- reactive({
totaldata[totaldata$week >= input$week[1] & totaldata$week <= input$week[2] & totaldata$country %in% input$countries,]
})
# Partners
rda <- reactive({
load(file="data/longTable_data.Rda")
})
# Partners
output$tableALL  <- DT :: renderDataTable({
load(file="data/longTable_data.Rda")
datatable(data = longTable_data,
colnames = c("Gender",
"Agegroup",
"Week",
"Country",
"Deaths",
"Expected Deaths",
"Excess Deaths"),
filter = "top",
options = list(pageLength = 5, autoWidth = 5, lengthMenu = 5, scrollX = T,
initComplete = JS(
"function(settings, json) {",
"$(this.api().table().header()).css({'background-color': '#517fb9', 'color': '#fff'});",
"}")),
class = 'cell-border stripe')
#longTable(5, TRUE, c(5, 10, 15, 20, 50, 100, 200, 500))}
})
# Partners
output$ggplotTable <- renderPlot ({
longTable_data_selection <- longTable_data[, c("week", "excess_deaths")] # Plot selection data
s1 <- input$tableALL_rows_all  # All filtered rows
df1 <- longTable_data_selection
if (length(s1)) {
df2 <- longTable_data_selection[s1, , drop = FALSE]
dat <- rbind(df1, df2)
dat$Group <- rep(factor(c("Original data", "Filtered data")),times = c(nrow(df1),nrow(df2)))
}
else {
dat <- df1
dat$Group <- rep("Original data", times = nrow(df1))
}
cols = c("Firebrick")
plot <- dat %>%
ggplot() +
geom_smooth(aes(x = week,
y = excess_deaths,
colour = Group)) +
labs(x = "Weeks", y = "Excess deaths") +
theme(plot.background=element_rect()) +
ggtitle("Filtered plot")
ggplotly(plot)
})
output$plot <- renderPlot({
p <- ggplot(data(), aes_string(x=input$x, y=input$y))
if (input$color != 'None')
p <- p + aes_string(color=input$color)
facets <- paste(input$facet_row, '~', input$facet_col)
if (facets != '. ~ .')
p <- p + facet_grid(facets)
if (input$jitter)
p <- p + geom_jitter()
if (input$smooth)
p <- p + geom_smooth()
if (input$actual)
p <- p + geom_point()
if (input$expected)
p <- p + geom_smooth(data = data(),
aes(x = week, y = expected_deaths))
print(p)
}, height=700)
}
# Remove comment for live test
shinyApp(ui, server)
runApp('Shiny')
runApp()
runApp('Shiny')
library(shiny)
library(ggplot2)
library(rsconnect)
# Partners libriaries
library(rsconnect)
library(kableExtra)
library(tidyverse)
library(tidygraph)
library(hrbrthemes)
library(viridis)
library(dygraphs)
library(xts)
library(lubridate)
library(plotly)
library(types)
library(pdftools)
library(gt)
library(scales)
library(formattable)
library(DT)
load(file = "data/totaldata.Rda")
load(file = "data/longTable_data.Rda")
source("ui.r")
server <- function(input, output) {
#observeEvent(input$clicks, {
#  print(as.numeric(input$clicks))
#})
#observe({print(input$clicks)})
data <- reactive({
totaldata[totaldata$week >= input$week[1] & totaldata$week <= input$week[2] & totaldata$country %in% input$countries,]
})
# Partners
rda <- reactive({
load(file="data/longTable_data.Rda")
})
# Partners
output$tableALL  <- DT :: renderDataTable({
load(file="data/longTable_data.Rda")
datatable(data = longTable_data,
colnames = c("Gender",
"Agegroup",
"Week",
"Country",
"Deaths",
"Expected Deaths",
"Excess Deaths"),
filter = "top",
options = list(pageLength = 5, autoWidth = 5, lengthMenu = 5, scrollX = T,
initComplete = JS(
"function(settings, json) {",
"$(this.api().table().header()).css({'background-color': '#517fb9', 'color': '#fff'});",
"}")),
class = 'cell-border stripe')
#longTable(5, TRUE, c(5, 10, 15, 20, 50, 100, 200, 500))}
})
# Partners
output$ggplotTable <- renderPlotly ({
longTable_data_selection <- longTable_data[, c("week", "excess_deaths")] # Plot selection data
s1 <- input$tableALL_rows_all  # All filtered rows
df1 <- longTable_data_selection
if (length(s1)) {
df2 <- longTable_data_selection[s1, , drop = FALSE]
dat <- rbind(df1, df2)
dat$Group <- rep(factor(c("Original data", "Filtered data")),times = c(nrow(df1),nrow(df2)))
}
else {
dat <- df1
dat$Group <- rep("Original data", times = nrow(df1))
}
cols = c("Firebrick")
plot <- dat %>%
ggplot2() +
geom_smooth(aes(x = week,
y = excess_deaths,
colour = Group)) +
labs(x = "Weeks", y = "Excess deaths") +
theme(plot.background=element_rect()) +
ggtitle("Filtered plot")
plot <- ggplotly(plot)
plot
})
output$plot <- renderPlot({
p <- ggplot(data(), aes_string(x=input$x, y=input$y))
if (input$color != 'None')
p <- p + aes_string(color=input$color)
facets <- paste(input$facet_row, '~', input$facet_col)
if (facets != '. ~ .')
p <- p + facet_grid(facets)
if (input$jitter)
p <- p + geom_jitter()
if (input$smooth)
p <- p + geom_smooth()
if (input$actual)
p <- p + geom_point()
if (input$expected)
p <- p + geom_smooth(data = data(),
aes(x = week, y = expected_deaths))
print(p)
}, height=700)
}
# Remove comment for live test
shinyApp(ui, server)
