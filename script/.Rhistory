"Creates a new data frame containing data from 2015-2019.
Comment: Check genderFunc_vector description in function section, and
sapply() description in description for data_norway (**)"
data_sweden_2015_2019 <-
data_sweden %>%
select(1:10, -"2015-2019") %>%    # Deselecting with '-' operator
pivot_longer(
cols = !"Vecka",
names_to = "values",
values_to = "deaths") %>%
mutate(year = "2015-2019",
gender = sapply(strsplit(values ," "), `[`, 1),
agegroup = sapply(strsplit(values ," "), `[`, 2)) %>%
select(-"values") %>%
rename(week = "Vecka")
"Creates a new data frame containing data from 2020"
data_sweden_2020 <- data_sweden %>%
select("Vecka", 12:19 ) %>%
pivot_longer(
cols = !"Vecka",
names_to = "values",
values_to = "deaths") %>%
mutate(year = "2020",
gender = sapply(strsplit(values ," "), `[`, 1),
agegroup = sapply(strsplit(values ," "), `[`, 2)) %>%
select(-"values") %>%
rename(week = "Vecka") %>%
filter(week <= 33)          # Because of zero deaths recording after week 33
"Combines data frames to a single data frame, mutates agegroup column to contain
the standardized agegrouping, selects useful columns and coerce these to
prefered datatypes"
data_sweden <- rbind(data_sweden_2015_2019,
data_sweden_2020) %>%
mutate(country = "Sweden") %>%
select(gender,
agegroup,
year,
week,
deaths,
country)
#### Data Denmark --------------------------------------------------------------
"Reads csv-file with read_delim() and separete it by ';', alternative:
read_csv2."
data_denmark <- read_delim("../datasett/Denmark/danmark_statbank_2013-2020.csv",
delim = ";",
skip = 2)
"Manipulates the data frame by selecting useful columns with [],
and mutatating gender column in to standardized gender name."
data_denmark <-
data_denmark[(25:70),-1] %>%
rename(gender = " _1",
agegroup = " _2") %>%
mutate(gender = substr(gender, 1, 1)) %>%
changeNonRecurringRow(., 1, 23) # Fills non recurring rows with given genders
"Further manipulation of data_denmark data frame. Deselecting irrelevant
columns, transpose all columns that starts with '20' in order to create
two column names to values column and values to the deaths column. Mutating
values column in to two columns named, year and week, by executing strsplitt()
for each rows in the values vector with sapply(). Grouping before summing
deaths for given grouping, then coerce given columns in data frame to
prefered datatype."
data_denmark <-
data_denmark[-c(1,2,24,25),] %>%
pivot_longer(cols = starts_with("20"),
names_to = "values",
values_to = "deaths") %>%
mutate(year = sapply(strsplit(values, "U"),'[', 1),
week = sapply(strsplit(values, "U"), '[', 2),
country = "Denmark") %>%
filter(!is.na(agegroup),
year >= 2014) %>%
group_by(gender,
agegroup,
year,
week) %>%
summarise(deaths = sum(deaths)) %>%
ungroup() %>%                       # Ungroup such that mutation is allowed
mutate(country = "Denmark")
#### Data UK ----------------------------------------------------------------
"UK datasets differ in the way they categorize age groups in the periods
2014-2019 and 2020. As a result of that getAgeVector transforms the agegroup
and returns the lower bound of the agegroup as a numeric value. The ageuniformiy
function then places the age in a fitting agegroup."
data_uk_2014 <- read_xls("../datasett/UK/UK_2014.xls",
sheet = "Weekly Figures 2014",
range = "A2:BA40") %>%
clean_data(.,                    # Function call to clean_data
2014,
selectColMale = c(1, 21, 23:29),
selectColFemale =  c(1, 30, 32:38))
data_uk_2015 <- read_xls("../datasett/UK/UK_2015.xls",
sheet = "Weekly Figures 2015",
range = "A3:BB40") %>%
clean_data(.,
2015,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2016 <- read_xls("../datasett/UK/UK_2016.xls",
sheet = "Weekly figures 2016",
range = "A3:BB40") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
clean_data(.,
2016,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2017 <- read_xls("../datasett/UK/UK_2017.xls",
sheet = "Weekly figures 2017",
range = "A3:BB40") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
clean_data(.,
2017,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2018 <- read_xls("../datasett/UK/UK_2018.xls",
sheet = "Weekly figures 2018",
range = "A3:BB40") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
clean_data(.,
2018,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2019 <- read_xls("../datasett/UK/UK_2019.xls",
sheet = "Weekly figures 2019",
range = "A3:BB40") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
clean_data(.,
2019,
selectColMale = c(1, 20, 22:28),
selectColFemale =  c(1, 29, 31:37))
data_uk_2020 <- read_xlsx("../datasett/UK/UK_2020.xlsx",
sheet = "Weekly figures 2020",
range = "A4:AI85") %>%
unite(., x, 1:2, na.rm = TRUE) %>%
custom_clean_data_2020(.,
2020,
selectColMale = c(1, 38, 40:59),
selectColFemale =  c(1, 60, 62:81))
# Binding all data frames created except from 2020
data_uk <- do.call("rbind", list(data_uk_2014,
data_uk_2015,
data_uk_2016,
data_uk_2017,
data_uk_2018,
data_uk_2019,
data_uk_2020)) %>%
select(gender,
agegroup,
year,
week ,
deaths,
country) %>%
group_by(gender,
agegroup,
year,
week) %>%
summarise(deaths = sum(deaths)) %>%
ungroup() %>%
mutate(country = "UK")
rm(data_uk_2014)
rm(data_uk_2015)
rm(data_uk_2016)
rm(data_uk_2017)
rm(data_uk_2018)
rm(data_uk_2019)
rm(data_uk_2020)
##### Data France -----------------------------------------------------------
"Gather csv filename from the France-folder in to a list"
datafiles_france <- list.files(path = "../datasett/France/",
pattern = "*.csv",
full.names = TRUE)
"Sapply() to read each file with read_csv2 with sep = ';',
then bind rows by id. The rest of the code does the cleaning"
data_france <- sapply(datafiles_france, read_csv2, simplify=FALSE) %>%
bind_rows(.id = "id") %>%
rename(day_dead = "JDEC",
month_dead = "MDEC",
year = "ADEC",
day_born = "JNAIS",
month_born = "MNAIS",
year_born = "ANAIS",
gender = "SEXE") %>%
transform(day_born = as.numeric(day_born),
month_born = as.numeric(month_born))  %>% # Replace missing values with NA
mutate(day_born = replace_na(day_born, 1), # Replace NA with 1
month_born = replace_na(month_born, 1),
date_born = ymd(paste(year_born, month_born, day_born)), ### Convert year month to single date of birth
date_dead = ymd(paste(year, month_dead, day_dead)),      ### Convert year month to single date of death
week = week(ymd(paste(year, month_dead, day_dead))),     ## Week of death
agegroup = as.period(interval(date_born, date_dead), unit = "year")$year) %>% ## Age at death
#agegroup = ageGroup_vector(age)) %>%
filter(!is.na(agegroup)) %>%
group_by(gender,
agegroup,
year,
week) %>%
summarise(deaths = n()) %>%
ungroup() %>%
mutate(country = "France")
#### Remove functions that are no longer needed in memory ----------------------
rm(ageGroup)
rm(ageGroup_vector)
rm(ageUniformityUK)
rm(ageUniformityUKVector)
rm(changeNonRecurringRow)
rm(clean_data)
rm(custom_clean_data_2020)
rm(getAge)
rm(getAgeVector)
rm(datafiles_france)
###################### Data standardisation script ##########################
"Libraries "
library(readxl)
library(readr)
library(tidyverse)
library(magrittr)
library(types)
library(lubridate)
library(janitor)
library(docstring)
"In case of sourcing the retrieval file directly to this file"
#source("data_retrieval.r")
getStandard <- function() {
#' Retrieve data standard excel sheet
#' @returns standard dataframe
return(read_csv("../datasett/Datastandard/data_standard.csv")) }
getFormat <- function(country) {
#' Returns the format file of a given country
#' @param country :
#' @returns new dataframe
path <- paste("../datasett/", country, "/") %>% gsub(" ", "",.)
formatFiles <- list.files(path = path,
pattern = "format",
full.names = TRUE)
ListofDF <- lapply(formatFiles, read_csv)
df <- bind_rows(ListofDF)
formatCorrectness(df) # Check for correctness
return (df)
}
formatCorrectness <- function(df) {
#' Checks correctness of format dataframe (imported as csv file)
#' @returns Error messsage if error found
colnames <- colnames(df)
if (!("Gender" %in% colnames) | !("Agegroups" %in% colnames) | !("AgeStandardGroup" %in% colnames)) {
stop("Format error: Missing one or more required columns")
}
if (length(which(!is.na(df$Agegroups))) != length(which(!is.na(df$AgeStandardGroup)))) {
stop("Format error: Missing values in agegroup or agegroupstandard")
}
}
#### Gender -----------------------------------------
standardiseGender <- function(df, country) {
#' In column gender, the function loops through all rows.
#' If it finds a match between the genderVector and standardGender it will return the standardGender
#' NA otherwise
#' @param df input dataframe
#' @param genderVec vector of original gender formatting in df
#' @returns a gender-standardized dataframe
standard <- getStandard() %>% filter(!is.na(Gender))
format <- getFormat(country) %>% filter(!is.na(Gender))
for (k in 1:nrow(df)) {
changedGender <- "No"
for (i in 1:length(format$Gender)) {
if (df$gender[k] == format$Gender[i]) {
df$gender[k] <- standard$Gender[i]
changedGender <- "Yes"
}
}
if (changedGender == "No") df$gender[k] <- NA
}
df <- df %>%
drop_na()
return (df)
}
#Test
sweden_gender <- standardiseGender(data_sweden, "Sweden")
norway_gender <- standardiseGender(data_norway, "Norway")
#### Age -------------------------------------------
getAge <- function(agestring, index) {
#' Function to convert a string og
#' @param agestring : string containing ages
#' @param index : index of the string to be returned e.g 2 -> returns "84" if agestring "80-84"
agestring <- (agestring %>%
strsplit(., "-"))[[1]] %>%
gsub("\\+", "", .)
if (length(agestring) == 1) return (agestring)
return (agestring[index])
}
ageToGroup <- function(df) {
#' Function to be used if the input dataframe does not have predetermined agegroups, but rather age as numeric valus.
#' Categorizes the dataframe ages as per defined in the standard format file
#' @param df : input dataframe
standard <- getStandard() %>% filter(!is.na(Agegroups))
for (k in 1:nrow(df)) {
for (i in 1:length(standard$Agegroups)) {
upperlimit <- getAge(standard$Agegroups[i], 2)
if (df$agegroup[k] <= upperlimit) {
df$agegroup[k] <- standard$Agegroups[i]
break
}
else if(i == length(standard$Agegroups)) df$agegroup[k] <- standard$Agegroups[i]
}
}
return (df)
}
#Test
#agetoGroupfrance <- ageToGroup(data_france)
standardiseAge <- function(df, country) {
#' Returns an age-standardised dataframe
#' We will end up with at the most the same number of unique agegroups, but if we end up with fewer,
#' a group_by -summarise operation is necessary to preserve the number of rows.
#'@param df : input dataframe
#'@param country: name of country to be standardised, string
#'@returns age-standardized dataframe
standard <- getStandard()
format <- getFormat(country)
if (format$Agegroups[1] == "Age") df <- ageToGroup(df)
else {
for (k in 1:nrow(df)) {
for (i in 1:length(format$Agegroups)) {
if (df$agegroup[k] == format$Agegroups[i]) {
standardIndex <-  format$AgeStandardGroup[i]
df$agegroup[k] <- standard$Agegroups[standardIndex]
}
}
}
}
df <-  df %>%
group_by(gender, agegroup,year,week) %>% #Preserve number of rows
summarise(deaths = sum(deaths),
country = country) %>% unique()
return (df)
}
############################################################################
standardiseCountry <- function(df, country) {
#' Standardizes a dataframe with regard to age and gender
#' @param df input dataframe
#' @param country name of country, string
df <- df %>%
standardiseGender(., country) %>%
standardiseAge(., country) %>%
drop_na() %>%
transform(gender = as.factor(gender),
agegroup = as.factor(agegroup),
week = as.numeric(week),
year = as.character(year),
deaths = as.numeric(deaths),
country = as.factor(country))
return (df)
}
# Data storage ------------------------------------------------------------------------
data_norway  %<>% standardiseCountry(., "Norway")
data_sweden  %<>% standardiseCountry(., "Sweden")
data_denmark %<>% standardiseCountry(., "Denmark")
data_uk      %<>% standardiseCountry(., "Denmark")
data_france  %<>% standardiseCountry(., "France")
"Saving the data frame to a .Rda-file for the purpose of analysis.r.
This is done for every data frames we have done in this file, the main purpose
is the the running time issue caused by large datasets, and this will reduce
the loading time significantly."
save(data_norway,data_sweden,data_denmark,data_uk,data_france, file = "../datasett/processed_data_all_countries.Rda")
###################### Data standardisation script ##########################
"Libraries "
library(readxl)
library(readr)
library(tidyverse)
library(magrittr)
library(types)
library(lubridate)
library(janitor)
library(docstring)
"In case of sourcing the retrieval file directly to this file"
source("data_retrieval.r")
getStandard <- function() {
#' Retrieve data standard excel sheet
#' @returns standard dataframe
return(read_csv("../datasett/Datastandard/data_standard.csv")) }
getFormat <- function(country) {
#' Returns the format file of a given country
#' @param country :
#' @returns new dataframe
path <- paste("../datasett/", country, "/") %>% gsub(" ", "",.)
formatFiles <- list.files(path = path,
pattern = "format",
full.names = TRUE)
ListofDF <- lapply(formatFiles, read_csv)
df <- bind_rows(ListofDF)
formatCorrectness(df) # Check for correctness
return (df)
}
formatCorrectness <- function(df) {
#' Checks correctness of format dataframe (imported as csv file)
#' @returns Error messsage if error found
colnames <- colnames(df)
if (!("Gender" %in% colnames) | !("Agegroups" %in% colnames) | !("AgeStandardGroup" %in% colnames)) {
stop("Format error: Missing one or more required columns")
}
if (length(which(!is.na(df$Agegroups))) != length(which(!is.na(df$AgeStandardGroup)))) {
stop("Format error: Missing values in agegroup or agegroupstandard")
}
}
#### Gender -----------------------------------------
standardiseGender <- function(df, country) {
#' In column gender, the function loops through all rows.
#' If it finds a match between the genderVector and standardGender it will return the standardGender
#' NA otherwise
#' @param df input dataframe
#' @param genderVec vector of original gender formatting in df
#' @returns a gender-standardized dataframe
standard <- getStandard() %>% filter(!is.na(Gender))
format <- getFormat(country) %>% filter(!is.na(Gender))
for (k in 1:nrow(df)) {
changedGender <- "No"
for (i in 1:length(format$Gender)) {
if (df$gender[k] == format$Gender[i]) {
df$gender[k] <- standard$Gender[i]
changedGender <- "Yes"
}
}
if (changedGender == "No") df$gender[k] <- NA
}
df <- df %>%
drop_na()
return (df)
}
#Test
sweden_gender <- standardiseGender(data_sweden, "Sweden")
norway_gender <- standardiseGender(data_norway, "Norway")
#### Age -------------------------------------------
getAge <- function(agestring, index) {
#' Function to convert a string og
#' @param agestring : string containing ages
#' @param index : index of the string to be returned e.g 2 -> returns "84" if agestring "80-84"
agestring <- (agestring %>%
strsplit(., "-"))[[1]] %>%
gsub("\\+", "", .)
if (length(agestring) == 1) return (agestring)
return (agestring[index])
}
ageToGroup <- function(df) {
#' Function to be used if the input dataframe does not have predetermined agegroups, but rather age as numeric valus.
#' Categorizes the dataframe ages as per defined in the standard format file
#' @param df : input dataframe
standard <- getStandard() %>% filter(!is.na(Agegroups))
for (k in 1:nrow(df)) {
for (i in 1:length(standard$Agegroups)) {
upperlimit <- getAge(standard$Agegroups[i], 2)
if (df$agegroup[k] <= upperlimit) {
df$agegroup[k] <- standard$Agegroups[i]
break
}
else if(i == length(standard$Agegroups)) df$agegroup[k] <- standard$Agegroups[i]
}
}
return (df)
}
#Test
#agetoGroupfrance <- ageToGroup(data_france)
standardiseAge <- function(df, country) {
#' Returns an age-standardised dataframe
#' We will end up with at the most the same number of unique agegroups, but if we end up with fewer,
#' a group_by -summarise operation is necessary to preserve the number of rows.
#'@param df : input dataframe
#'@param country: name of country to be standardised, string
#'@returns age-standardized dataframe
standard <- getStandard()
format <- getFormat(country)
if (format$Agegroups[1] == "Age") df <- ageToGroup(df)
else {
for (k in 1:nrow(df)) {
for (i in 1:length(format$Agegroups)) {
if (df$agegroup[k] == format$Agegroups[i]) {
standardIndex <-  format$AgeStandardGroup[i]
df$agegroup[k] <- standard$Agegroups[standardIndex]
}
}
}
}
df <-  df %>%
group_by(gender, agegroup,year,week) %>% #Preserve number of rows
summarise(deaths = sum(deaths),
country = country) %>% unique()
return (df)
}
############################################################################
standardiseCountry <- function(df, country) {
#' Standardizes a dataframe with regard to age and gender
#' @param df input dataframe
#' @param country name of country, string
df <- df %>%
standardiseGender(., country) %>%
standardiseAge(., country) %>%
drop_na() %>%
transform(gender = as.factor(gender),
agegroup = as.factor(agegroup),
week = as.numeric(week),
year = as.character(year),
deaths = as.numeric(deaths),
country = as.factor(country))
return (df)
}
# Data storage ------------------------------------------------------------------------
data_norway  %<>% standardiseCountry(., "Norway")
data_sweden  %<>% standardiseCountry(., "Sweden")
data_denmark %<>% standardiseCountry(., "Denmark")
data_uk      %<>% standardiseCountry(., "Denmark")
data_france  %<>% standardiseCountry(., "France")
"Saving the data frame to a .Rda-file for the purpose of analysis.r.
This is done for every data frames we have done in this file, the main purpose
is the the running time issue caused by large datasets, and this will reduce
the loading time significantly."
save(data_norway,data_sweden,data_denmark,data_uk,data_france, file = "../datasett/processed_data_all_countries.Rda")
View(data_france)
